// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.proto

package message

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//msgid=0xc487
type NodeCapacityRequest struct {
	RequestMsgID         int32    `protobuf:"varint,1,opt,name=RequestMsgID,proto3" json:"RequestMsgID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeCapacityRequest) Reset()         { *m = NodeCapacityRequest{} }
func (m *NodeCapacityRequest) String() string { return proto.CompactTextString(m) }
func (*NodeCapacityRequest) ProtoMessage()    {}
func (*NodeCapacityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}
func (m *NodeCapacityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCapacityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCapacityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCapacityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCapacityRequest.Merge(m, src)
}
func (m *NodeCapacityRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeCapacityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCapacityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCapacityRequest proto.InternalMessageInfo

func (m *NodeCapacityRequest) GetRequestMsgID() int32 {
	if m != nil {
		return m.RequestMsgID
	}
	return 0
}

//msgid=0xe684
type NodeCapacityResponse struct {
	Writable             bool     `protobuf:"varint,1,opt,name=writable,proto3" json:"writable,omitempty"`
	AllocId              string   `protobuf:"bytes,2,opt,name=allocId,proto3" json:"allocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeCapacityResponse) Reset()         { *m = NodeCapacityResponse{} }
func (m *NodeCapacityResponse) String() string { return proto.CompactTextString(m) }
func (*NodeCapacityResponse) ProtoMessage()    {}
func (*NodeCapacityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}
func (m *NodeCapacityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCapacityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCapacityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCapacityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCapacityResponse.Merge(m, src)
}
func (m *NodeCapacityResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeCapacityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCapacityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCapacityResponse proto.InternalMessageInfo

func (m *NodeCapacityResponse) GetWritable() bool {
	if m != nil {
		return m.Writable
	}
	return false
}

func (m *NodeCapacityResponse) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

//msgid=0xCB05
type UploadShardRequest struct {
	SHARDID              int32    `protobuf:"varint,1,opt,name=SHARDID,proto3" json:"SHARDID,omitempty"`
	BPDID                int32    `protobuf:"varint,2,opt,name=BPDID,proto3" json:"BPDID,omitempty"`
	VBI                  int64    `protobuf:"varint,3,opt,name=VBI,proto3" json:"VBI,omitempty"`
	BPDSIGN              []byte   `protobuf:"bytes,4,opt,name=BPDSIGN,proto3" json:"BPDSIGN,omitempty"`
	DAT                  []byte   `protobuf:"bytes,5,opt,name=DAT,proto3" json:"DAT,omitempty"`
	VHF                  []byte   `protobuf:"bytes,6,opt,name=VHF,proto3" json:"VHF,omitempty"`
	USERSIGN             []byte   `protobuf:"bytes,7,opt,name=USERSIGN,proto3" json:"USERSIGN,omitempty"`
	AllocId              string   `protobuf:"bytes,8,opt,name=allocId,proto3" json:"allocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadShardRequest) Reset()         { *m = UploadShardRequest{} }
func (m *UploadShardRequest) String() string { return proto.CompactTextString(m) }
func (*UploadShardRequest) ProtoMessage()    {}
func (*UploadShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{2}
}
func (m *UploadShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadShardRequest.Merge(m, src)
}
func (m *UploadShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadShardRequest proto.InternalMessageInfo

func (m *UploadShardRequest) GetSHARDID() int32 {
	if m != nil {
		return m.SHARDID
	}
	return 0
}

func (m *UploadShardRequest) GetBPDID() int32 {
	if m != nil {
		return m.BPDID
	}
	return 0
}

func (m *UploadShardRequest) GetVBI() int64 {
	if m != nil {
		return m.VBI
	}
	return 0
}

func (m *UploadShardRequest) GetBPDSIGN() []byte {
	if m != nil {
		return m.BPDSIGN
	}
	return nil
}

func (m *UploadShardRequest) GetDAT() []byte {
	if m != nil {
		return m.DAT
	}
	return nil
}

func (m *UploadShardRequest) GetVHF() []byte {
	if m != nil {
		return m.VHF
	}
	return nil
}

func (m *UploadShardRequest) GetUSERSIGN() []byte {
	if m != nil {
		return m.USERSIGN
	}
	return nil
}

func (m *UploadShardRequest) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

type UploadShardResponse struct {
	RES                  int32    `protobuf:"varint,1,opt,name=RES,proto3" json:"RES,omitempty"`
	SHARDID              int32    `protobuf:"varint,2,opt,name=SHARDID,proto3" json:"SHARDID,omitempty"`
	VBI                  int64    `protobuf:"varint,3,opt,name=VBI,proto3" json:"VBI,omitempty"`
	VHF                  []byte   `protobuf:"bytes,4,opt,name=VHF,proto3" json:"VHF,omitempty"`
	USERSIGN             []byte   `protobuf:"bytes,5,opt,name=USERSIGN,proto3" json:"USERSIGN,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadShardResponse) Reset()         { *m = UploadShardResponse{} }
func (m *UploadShardResponse) String() string { return proto.CompactTextString(m) }
func (*UploadShardResponse) ProtoMessage()    {}
func (*UploadShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{3}
}
func (m *UploadShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadShardResponse.Merge(m, src)
}
func (m *UploadShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadShardResponse proto.InternalMessageInfo

func (m *UploadShardResponse) GetRES() int32 {
	if m != nil {
		return m.RES
	}
	return 0
}

func (m *UploadShardResponse) GetSHARDID() int32 {
	if m != nil {
		return m.SHARDID
	}
	return 0
}

func (m *UploadShardResponse) GetVBI() int64 {
	if m != nil {
		return m.VBI
	}
	return 0
}

func (m *UploadShardResponse) GetVHF() []byte {
	if m != nil {
		return m.VHF
	}
	return nil
}

func (m *UploadShardResponse) GetUSERSIGN() []byte {
	if m != nil {
		return m.USERSIGN
	}
	return nil
}

type UploadShard2CResponse struct {
	RES                  int32    `protobuf:"varint,1,opt,name=RES,proto3" json:"RES,omitempty"`
	DNSIGN               string   `protobuf:"bytes,2,opt,name=DNSIGN,proto3" json:"DNSIGN,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadShard2CResponse) Reset()         { *m = UploadShard2CResponse{} }
func (m *UploadShard2CResponse) String() string { return proto.CompactTextString(m) }
func (*UploadShard2CResponse) ProtoMessage()    {}
func (*UploadShard2CResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{4}
}
func (m *UploadShard2CResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadShard2CResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadShard2CResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadShard2CResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadShard2CResponse.Merge(m, src)
}
func (m *UploadShard2CResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadShard2CResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadShard2CResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadShard2CResponse proto.InternalMessageInfo

func (m *UploadShard2CResponse) GetRES() int32 {
	if m != nil {
		return m.RES
	}
	return 0
}

func (m *UploadShard2CResponse) GetDNSIGN() string {
	if m != nil {
		return m.DNSIGN
	}
	return ""
}

type DownloadShardRequest struct {
	VHF                  []byte   `protobuf:"bytes,1,opt,name=VHF,proto3" json:"VHF,omitempty"`
	AllocId              string   `protobuf:"bytes,2,opt,name=allocId,proto3" json:"allocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadShardRequest) Reset()         { *m = DownloadShardRequest{} }
func (m *DownloadShardRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadShardRequest) ProtoMessage()    {}
func (*DownloadShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{5}
}
func (m *DownloadShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadShardRequest.Merge(m, src)
}
func (m *DownloadShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadShardRequest proto.InternalMessageInfo

func (m *DownloadShardRequest) GetVHF() []byte {
	if m != nil {
		return m.VHF
	}
	return nil
}

func (m *DownloadShardRequest) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

type DownloadShardResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadShardResponse) Reset()         { *m = DownloadShardResponse{} }
func (m *DownloadShardResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadShardResponse) ProtoMessage()    {}
func (*DownloadShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{6}
}
func (m *DownloadShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadShardResponse.Merge(m, src)
}
func (m *DownloadShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadShardResponse proto.InternalMessageInfo

func (m *DownloadShardResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type NodeRegReq struct {
	Nodeid               string   `protobuf:"bytes,1,opt,name=nodeid,proto3" json:"nodeid,omitempty"`
	Owner                string   `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	MaxDataSpace         uint64   `protobuf:"varint,3,opt,name=maxDataSpace,proto3" json:"maxDataSpace,omitempty"`
	Addrs                []string `protobuf:"bytes,4,rep,name=addrs,proto3" json:"addrs,omitempty"`
	Relay                bool     `protobuf:"varint,5,opt,name=relay,proto3" json:"relay,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeRegReq) Reset()         { *m = NodeRegReq{} }
func (m *NodeRegReq) String() string { return proto.CompactTextString(m) }
func (*NodeRegReq) ProtoMessage()    {}
func (*NodeRegReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{7}
}
func (m *NodeRegReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRegReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeRegReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeRegReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRegReq.Merge(m, src)
}
func (m *NodeRegReq) XXX_Size() int {
	return m.Size()
}
func (m *NodeRegReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRegReq.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRegReq proto.InternalMessageInfo

func (m *NodeRegReq) GetNodeid() string {
	if m != nil {
		return m.Nodeid
	}
	return ""
}

func (m *NodeRegReq) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *NodeRegReq) GetMaxDataSpace() uint64 {
	if m != nil {
		return m.MaxDataSpace
	}
	return 0
}

func (m *NodeRegReq) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *NodeRegReq) GetRelay() bool {
	if m != nil {
		return m.Relay
	}
	return false
}

type NodeRegResp struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AssignedSpace        uint64   `protobuf:"varint,2,opt,name=assignedSpace,proto3" json:"assignedSpace,omitempty"`
	RelayUrl             string   `protobuf:"bytes,3,opt,name=relayUrl,proto3" json:"relayUrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeRegResp) Reset()         { *m = NodeRegResp{} }
func (m *NodeRegResp) String() string { return proto.CompactTextString(m) }
func (*NodeRegResp) ProtoMessage()    {}
func (*NodeRegResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{8}
}
func (m *NodeRegResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRegResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeRegResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeRegResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRegResp.Merge(m, src)
}
func (m *NodeRegResp) XXX_Size() int {
	return m.Size()
}
func (m *NodeRegResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRegResp.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRegResp proto.InternalMessageInfo

func (m *NodeRegResp) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NodeRegResp) GetAssignedSpace() uint64 {
	if m != nil {
		return m.AssignedSpace
	}
	return 0
}

func (m *NodeRegResp) GetRelayUrl() string {
	if m != nil {
		return m.RelayUrl
	}
	return ""
}

type StatusRepReq struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Cpu                  uint32   `protobuf:"varint,2,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory               uint32   `protobuf:"varint,3,opt,name=memory,proto3" json:"memory,omitempty"`
	Bandwidth            uint32   `protobuf:"varint,4,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	MaxDataSpace         uint64   `protobuf:"varint,5,opt,name=maxDataSpace,proto3" json:"maxDataSpace,omitempty"`
	AssignedSpace        uint64   `protobuf:"varint,6,opt,name=assignedSpace,proto3" json:"assignedSpace,omitempty"`
	UsedSpace            uint64   `protobuf:"varint,7,opt,name=usedSpace,proto3" json:"usedSpace,omitempty"`
	Addrs                []string `protobuf:"bytes,8,rep,name=addrs,proto3" json:"addrs,omitempty"`
	Relay                bool     `protobuf:"varint,9,opt,name=relay,proto3" json:"relay,omitempty"`
	Version              uint32   `protobuf:"varint,10,opt,name=version,proto3" json:"version,omitempty"`
	Rebuilding           uint32   `protobuf:"varint,11,opt,name=rebuilding,proto3" json:"rebuilding,omitempty"`
	RealSpace            uint32   `protobuf:"varint,12,opt,name=realSpace,proto3" json:"realSpace,omitempty"`
	Tx                   uint64   `protobuf:"varint,13,opt,name=tx,proto3" json:"tx,omitempty"`
	Rx                   uint64   `protobuf:"varint,14,opt,name=rx,proto3" json:"rx,omitempty"`
	Other                string   `protobuf:"bytes,15,opt,name=Other,proto3" json:"Other,omitempty"`
	Hash                 string   `protobuf:"bytes,16,opt,name=hash,proto3" json:"hash,omitempty"`
	AllocSpace           uint64   `protobuf:"varint,17,opt,name=allocSpace,proto3" json:"allocSpace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusRepReq) Reset()         { *m = StatusRepReq{} }
func (m *StatusRepReq) String() string { return proto.CompactTextString(m) }
func (*StatusRepReq) ProtoMessage()    {}
func (*StatusRepReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{9}
}
func (m *StatusRepReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusRepReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusRepReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusRepReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusRepReq.Merge(m, src)
}
func (m *StatusRepReq) XXX_Size() int {
	return m.Size()
}
func (m *StatusRepReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusRepReq.DiscardUnknown(m)
}

var xxx_messageInfo_StatusRepReq proto.InternalMessageInfo

func (m *StatusRepReq) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StatusRepReq) GetCpu() uint32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *StatusRepReq) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *StatusRepReq) GetBandwidth() uint32 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *StatusRepReq) GetMaxDataSpace() uint64 {
	if m != nil {
		return m.MaxDataSpace
	}
	return 0
}

func (m *StatusRepReq) GetAssignedSpace() uint64 {
	if m != nil {
		return m.AssignedSpace
	}
	return 0
}

func (m *StatusRepReq) GetUsedSpace() uint64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *StatusRepReq) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *StatusRepReq) GetRelay() bool {
	if m != nil {
		return m.Relay
	}
	return false
}

func (m *StatusRepReq) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *StatusRepReq) GetRebuilding() uint32 {
	if m != nil {
		return m.Rebuilding
	}
	return 0
}

func (m *StatusRepReq) GetRealSpace() uint32 {
	if m != nil {
		return m.RealSpace
	}
	return 0
}

func (m *StatusRepReq) GetTx() uint64 {
	if m != nil {
		return m.Tx
	}
	return 0
}

func (m *StatusRepReq) GetRx() uint64 {
	if m != nil {
		return m.Rx
	}
	return 0
}

func (m *StatusRepReq) GetOther() string {
	if m != nil {
		return m.Other
	}
	return ""
}

func (m *StatusRepReq) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *StatusRepReq) GetAllocSpace() uint64 {
	if m != nil {
		return m.AllocSpace
	}
	return 0
}

type StatusRepResp struct {
	ProductiveSpace      int64    `protobuf:"varint,1,opt,name=productiveSpace,proto3" json:"productiveSpace,omitempty"`
	RelayUrl             string   `protobuf:"bytes,2,opt,name=relayUrl,proto3" json:"relayUrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusRepResp) Reset()         { *m = StatusRepResp{} }
func (m *StatusRepResp) String() string { return proto.CompactTextString(m) }
func (*StatusRepResp) ProtoMessage()    {}
func (*StatusRepResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{10}
}
func (m *StatusRepResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusRepResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusRepResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusRepResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusRepResp.Merge(m, src)
}
func (m *StatusRepResp) XXX_Size() int {
	return m.Size()
}
func (m *StatusRepResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusRepResp.DiscardUnknown(m)
}

var xxx_messageInfo_StatusRepResp proto.InternalMessageInfo

func (m *StatusRepResp) GetProductiveSpace() int64 {
	if m != nil {
		return m.ProductiveSpace
	}
	return 0
}

func (m *StatusRepResp) GetRelayUrl() string {
	if m != nil {
		return m.RelayUrl
	}
	return ""
}

type ErrorMessage struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ErrorMessage) Reset()         { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()    {}
func (*ErrorMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{11}
}
func (m *ErrorMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorMessage.Merge(m, src)
}
func (m *ErrorMessage) XXX_Size() int {
	return m.Size()
}
func (m *ErrorMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorMessage proto.InternalMessageInfo

func (m *ErrorMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrorMessage) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type StringMsg struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringMsg) Reset()         { *m = StringMsg{} }
func (m *StringMsg) String() string { return proto.CompactTextString(m) }
func (*StringMsg) ProtoMessage()    {}
func (*StringMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{12}
}
func (m *StringMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringMsg.Merge(m, src)
}
func (m *StringMsg) XXX_Size() int {
	return m.Size()
}
func (m *StringMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_StringMsg.DiscardUnknown(m)
}

var xxx_messageInfo_StringMsg proto.InternalMessageInfo

func (m *StringMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type SpotCheckTaskList struct {
	TaskId               string           `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Snid                 int32            `protobuf:"varint,2,opt,name=snid,proto3" json:"snid,omitempty"`
	TaskList             []*SpotCheckTask `protobuf:"bytes,3,rep,name=taskList,proto3" json:"taskList,omitempty"`
	AllocId              string           `protobuf:"bytes,4,opt,name=allocId,proto3" json:"allocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SpotCheckTaskList) Reset()         { *m = SpotCheckTaskList{} }
func (m *SpotCheckTaskList) String() string { return proto.CompactTextString(m) }
func (*SpotCheckTaskList) ProtoMessage()    {}
func (*SpotCheckTaskList) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{13}
}
func (m *SpotCheckTaskList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotCheckTaskList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotCheckTaskList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotCheckTaskList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotCheckTaskList.Merge(m, src)
}
func (m *SpotCheckTaskList) XXX_Size() int {
	return m.Size()
}
func (m *SpotCheckTaskList) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotCheckTaskList.DiscardUnknown(m)
}

var xxx_messageInfo_SpotCheckTaskList proto.InternalMessageInfo

func (m *SpotCheckTaskList) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *SpotCheckTaskList) GetSnid() int32 {
	if m != nil {
		return m.Snid
	}
	return 0
}

func (m *SpotCheckTaskList) GetTaskList() []*SpotCheckTask {
	if m != nil {
		return m.TaskList
	}
	return nil
}

func (m *SpotCheckTaskList) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

type SpotCheckTask struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId               string   `protobuf:"bytes,2,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	VHF                  []byte   `protobuf:"bytes,4,opt,name=VHF,proto3" json:"VHF,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpotCheckTask) Reset()         { *m = SpotCheckTask{} }
func (m *SpotCheckTask) String() string { return proto.CompactTextString(m) }
func (*SpotCheckTask) ProtoMessage()    {}
func (*SpotCheckTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{14}
}
func (m *SpotCheckTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotCheckTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotCheckTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotCheckTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotCheckTask.Merge(m, src)
}
func (m *SpotCheckTask) XXX_Size() int {
	return m.Size()
}
func (m *SpotCheckTask) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotCheckTask.DiscardUnknown(m)
}

var xxx_messageInfo_SpotCheckTask proto.InternalMessageInfo

func (m *SpotCheckTask) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SpotCheckTask) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *SpotCheckTask) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *SpotCheckTask) GetVHF() []byte {
	if m != nil {
		return m.VHF
	}
	return nil
}

type SpotCheckStatus struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	InvalidNodeList      []int32  `protobuf:"varint,2,rep,packed,name=invalidNodeList,proto3" json:"invalidNodeList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpotCheckStatus) Reset()         { *m = SpotCheckStatus{} }
func (m *SpotCheckStatus) String() string { return proto.CompactTextString(m) }
func (*SpotCheckStatus) ProtoMessage()    {}
func (*SpotCheckStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{15}
}
func (m *SpotCheckStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpotCheckStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpotCheckStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpotCheckStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpotCheckStatus.Merge(m, src)
}
func (m *SpotCheckStatus) XXX_Size() int {
	return m.Size()
}
func (m *SpotCheckStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SpotCheckStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SpotCheckStatus proto.InternalMessageInfo

func (m *SpotCheckStatus) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *SpotCheckStatus) GetInvalidNodeList() []int32 {
	if m != nil {
		return m.InvalidNodeList
	}
	return nil
}

//RS编码重建任务
//msgid=0xd761
type TaskDescription struct {
	Id                   []byte         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Hashs                [][]byte       `protobuf:"bytes,2,rep,name=hashs,proto3" json:"hashs,omitempty"`
	Locations            []*P2PLocation `protobuf:"bytes,3,rep,name=locations,proto3" json:"locations,omitempty"`
	ParityShardCount     int32          `protobuf:"varint,4,opt,name=parityShardCount,proto3" json:"parityShardCount,omitempty"`
	RecoverId            int32          `protobuf:"varint,5,opt,name=recoverId,proto3" json:"recoverId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TaskDescription) Reset()         { *m = TaskDescription{} }
func (m *TaskDescription) String() string { return proto.CompactTextString(m) }
func (*TaskDescription) ProtoMessage()    {}
func (*TaskDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{16}
}
func (m *TaskDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskDescription.Merge(m, src)
}
func (m *TaskDescription) XXX_Size() int {
	return m.Size()
}
func (m *TaskDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskDescription.DiscardUnknown(m)
}

var xxx_messageInfo_TaskDescription proto.InternalMessageInfo

func (m *TaskDescription) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TaskDescription) GetHashs() [][]byte {
	if m != nil {
		return m.Hashs
	}
	return nil
}

func (m *TaskDescription) GetLocations() []*P2PLocation {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *TaskDescription) GetParityShardCount() int32 {
	if m != nil {
		return m.ParityShardCount
	}
	return 0
}

func (m *TaskDescription) GetRecoverId() int32 {
	if m != nil {
		return m.RecoverId
	}
	return 0
}

//msgid=0xc258
type TaskDescriptionCP struct {
	Id                   []byte         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DataHash             []byte         `protobuf:"bytes,2,opt,name=dataHash,proto3" json:"dataHash,omitempty"`
	Locations            []*P2PLocation `protobuf:"bytes,3,rep,name=locations,proto3" json:"locations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TaskDescriptionCP) Reset()         { *m = TaskDescriptionCP{} }
func (m *TaskDescriptionCP) String() string { return proto.CompactTextString(m) }
func (*TaskDescriptionCP) ProtoMessage()    {}
func (*TaskDescriptionCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{17}
}
func (m *TaskDescriptionCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskDescriptionCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskDescriptionCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskDescriptionCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskDescriptionCP.Merge(m, src)
}
func (m *TaskDescriptionCP) XXX_Size() int {
	return m.Size()
}
func (m *TaskDescriptionCP) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskDescriptionCP.DiscardUnknown(m)
}

var xxx_messageInfo_TaskDescriptionCP proto.InternalMessageInfo

func (m *TaskDescriptionCP) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TaskDescriptionCP) GetDataHash() []byte {
	if m != nil {
		return m.DataHash
	}
	return nil
}

func (m *TaskDescriptionCP) GetLocations() []*P2PLocation {
	if m != nil {
		return m.Locations
	}
	return nil
}

type P2PLocation struct {
	NodeId               string   `protobuf:"bytes,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	Addrs                []string `protobuf:"bytes,2,rep,name=addrs,proto3" json:"addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *P2PLocation) Reset()         { *m = P2PLocation{} }
func (m *P2PLocation) String() string { return proto.CompactTextString(m) }
func (*P2PLocation) ProtoMessage()    {}
func (*P2PLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{18}
}
func (m *P2PLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P2PLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P2PLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P2PLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P2PLocation.Merge(m, src)
}
func (m *P2PLocation) XXX_Size() int {
	return m.Size()
}
func (m *P2PLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_P2PLocation.DiscardUnknown(m)
}

var xxx_messageInfo_P2PLocation proto.InternalMessageInfo

func (m *P2PLocation) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *P2PLocation) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

//矿机收到任务请回复VoidResp
//msgid=0xe64f
type VoidResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VoidResponse) Reset()         { *m = VoidResponse{} }
func (m *VoidResponse) String() string { return proto.CompactTextString(m) }
func (*VoidResponse) ProtoMessage()    {}
func (*VoidResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{19}
}
func (m *VoidResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoidResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoidResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoidResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoidResponse.Merge(m, src)
}
func (m *VoidResponse) XXX_Size() int {
	return m.Size()
}
func (m *VoidResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VoidResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VoidResponse proto.InternalMessageInfo

//矿机重建完毕后向任务发起方SN返回结果
//msgid=0x16f3
type TaskOpResult struct {
	Id                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	RES                  int32    `protobuf:"varint,2,opt,name=RES,proto3" json:"RES,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskOpResult) Reset()         { *m = TaskOpResult{} }
func (m *TaskOpResult) String() string { return proto.CompactTextString(m) }
func (*TaskOpResult) ProtoMessage()    {}
func (*TaskOpResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{20}
}
func (m *TaskOpResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskOpResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskOpResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskOpResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskOpResult.Merge(m, src)
}
func (m *TaskOpResult) XXX_Size() int {
	return m.Size()
}
func (m *TaskOpResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskOpResult.DiscardUnknown(m)
}

var xxx_messageInfo_TaskOpResult proto.InternalMessageInfo

func (m *TaskOpResult) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *TaskOpResult) GetRES() int32 {
	if m != nil {
		return m.RES
	}
	return 0
}

//MessageID:2cb0
type MultiTaskDescription struct {
	Tasklist             [][]byte `protobuf:"bytes,1,rep,name=tasklist,proto3" json:"tasklist,omitempty"`
	ExpiredTime          int64    `protobuf:"varint,2,opt,name=expiredTime,proto3" json:"expiredTime,omitempty"`
	SrcNodeID            int32    `protobuf:"varint,3,opt,name=srcNodeID,proto3" json:"srcNodeID,omitempty"`
	ExpiredTimeGap       int32    `protobuf:"varint,4,opt,name=expiredTimeGap,proto3" json:"expiredTimeGap,omitempty"`
	AllocId              string   `protobuf:"bytes,5,opt,name=allocId,proto3" json:"allocId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiTaskDescription) Reset()         { *m = MultiTaskDescription{} }
func (m *MultiTaskDescription) String() string { return proto.CompactTextString(m) }
func (*MultiTaskDescription) ProtoMessage()    {}
func (*MultiTaskDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{21}
}
func (m *MultiTaskDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiTaskDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiTaskDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiTaskDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiTaskDescription.Merge(m, src)
}
func (m *MultiTaskDescription) XXX_Size() int {
	return m.Size()
}
func (m *MultiTaskDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiTaskDescription.DiscardUnknown(m)
}

var xxx_messageInfo_MultiTaskDescription proto.InternalMessageInfo

func (m *MultiTaskDescription) GetTasklist() [][]byte {
	if m != nil {
		return m.Tasklist
	}
	return nil
}

func (m *MultiTaskDescription) GetExpiredTime() int64 {
	if m != nil {
		return m.ExpiredTime
	}
	return 0
}

func (m *MultiTaskDescription) GetSrcNodeID() int32 {
	if m != nil {
		return m.SrcNodeID
	}
	return 0
}

func (m *MultiTaskDescription) GetExpiredTimeGap() int32 {
	if m != nil {
		return m.ExpiredTimeGap
	}
	return 0
}

func (m *MultiTaskDescription) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

//MessageID:1b31
type MultiTaskOpResult struct {
	Id                   [][]byte `protobuf:"bytes,1,rep,name=id,proto3" json:"id,omitempty"`
	RES                  []int32  `protobuf:"varint,2,rep,packed,name=RES,proto3" json:"RES,omitempty"`
	NodeID               int32    `protobuf:"varint,3,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	ExpiredTime          int64    `protobuf:"varint,4,opt,name=expiredTime,proto3" json:"expiredTime,omitempty"`
	SrcNodeID            int32    `protobuf:"varint,5,opt,name=srcNodeID,proto3" json:"srcNodeID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiTaskOpResult) Reset()         { *m = MultiTaskOpResult{} }
func (m *MultiTaskOpResult) String() string { return proto.CompactTextString(m) }
func (*MultiTaskOpResult) ProtoMessage()    {}
func (*MultiTaskOpResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{22}
}
func (m *MultiTaskOpResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiTaskOpResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiTaskOpResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiTaskOpResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiTaskOpResult.Merge(m, src)
}
func (m *MultiTaskOpResult) XXX_Size() int {
	return m.Size()
}
func (m *MultiTaskOpResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiTaskOpResult.DiscardUnknown(m)
}

var xxx_messageInfo_MultiTaskOpResult proto.InternalMessageInfo

func (m *MultiTaskOpResult) GetId() [][]byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *MultiTaskOpResult) GetRES() []int32 {
	if m != nil {
		return m.RES
	}
	return nil
}

func (m *MultiTaskOpResult) GetNodeID() int32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *MultiTaskOpResult) GetExpiredTime() int64 {
	if m != nil {
		return m.ExpiredTime
	}
	return 0
}

func (m *MultiTaskOpResult) GetSrcNodeID() int32 {
	if m != nil {
		return m.SrcNodeID
	}
	return 0
}

//MessageID:93e4
type MultiTaskOpResultRes struct {
	ErrCode              int32    `protobuf:"varint,1,opt,name=errCode,proto3" json:"errCode,omitempty"`
	SuccNum              int32    `protobuf:"varint,2,opt,name=SuccNum,proto3" json:"SuccNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiTaskOpResultRes) Reset()         { *m = MultiTaskOpResultRes{} }
func (m *MultiTaskOpResultRes) String() string { return proto.CompactTextString(m) }
func (*MultiTaskOpResultRes) ProtoMessage()    {}
func (*MultiTaskOpResultRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{23}
}
func (m *MultiTaskOpResultRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiTaskOpResultRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiTaskOpResultRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiTaskOpResultRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiTaskOpResultRes.Merge(m, src)
}
func (m *MultiTaskOpResultRes) XXX_Size() int {
	return m.Size()
}
func (m *MultiTaskOpResultRes) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiTaskOpResultRes.DiscardUnknown(m)
}

var xxx_messageInfo_MultiTaskOpResultRes proto.InternalMessageInfo

func (m *MultiTaskOpResultRes) GetErrCode() int32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *MultiTaskOpResultRes) GetSuccNum() int32 {
	if m != nil {
		return m.SuccNum
	}
	return 0
}

//msgid=0x4bc6
type ListDNIReq struct {
	Nextid               string   `protobuf:"bytes,1,opt,name=nextid,proto3" json:"nextid,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDNIReq) Reset()         { *m = ListDNIReq{} }
func (m *ListDNIReq) String() string { return proto.CompactTextString(m) }
func (*ListDNIReq) ProtoMessage()    {}
func (*ListDNIReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{24}
}
func (m *ListDNIReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDNIReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDNIReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDNIReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDNIReq.Merge(m, src)
}
func (m *ListDNIReq) XXX_Size() int {
	return m.Size()
}
func (m *ListDNIReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDNIReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListDNIReq proto.InternalMessageInfo

func (m *ListDNIReq) GetNextid() string {
	if m != nil {
		return m.Nextid
	}
	return ""
}

func (m *ListDNIReq) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

//msgid=0xd6cb
type ListDNIResp struct {
	Vnflist              [][]byte `protobuf:"bytes,1,rep,name=vnflist,proto3" json:"vnflist,omitempty"`
	Nextid               string   `protobuf:"bytes,2,opt,name=nextid,proto3" json:"nextid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDNIResp) Reset()         { *m = ListDNIResp{} }
func (m *ListDNIResp) String() string { return proto.CompactTextString(m) }
func (*ListDNIResp) ProtoMessage()    {}
func (*ListDNIResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{25}
}
func (m *ListDNIResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDNIResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDNIResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDNIResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDNIResp.Merge(m, src)
}
func (m *ListDNIResp) XXX_Size() int {
	return m.Size()
}
func (m *ListDNIResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDNIResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListDNIResp proto.InternalMessageInfo

func (m *ListDNIResp) GetVnflist() [][]byte {
	if m != nil {
		return m.Vnflist
	}
	return nil
}

func (m *ListDNIResp) GetNextid() string {
	if m != nil {
		return m.Nextid
	}
	return ""
}

//  本次需要校验的条数
//msgid = 0xd97a
type SelfVerifyReq struct {
	Num                  string   `protobuf:"bytes,1,opt,name=Num,proto3" json:"Num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SelfVerifyReq) Reset()         { *m = SelfVerifyReq{} }
func (m *SelfVerifyReq) String() string { return proto.CompactTextString(m) }
func (*SelfVerifyReq) ProtoMessage()    {}
func (*SelfVerifyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{26}
}
func (m *SelfVerifyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SelfVerifyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SelfVerifyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SelfVerifyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SelfVerifyReq.Merge(m, src)
}
func (m *SelfVerifyReq) XXX_Size() int {
	return m.Size()
}
func (m *SelfVerifyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SelfVerifyReq.DiscardUnknown(m)
}

var xxx_messageInfo_SelfVerifyReq proto.InternalMessageInfo

func (m *SelfVerifyReq) GetNum() string {
	if m != nil {
		return m.Num
	}
	return ""
}

type HashToHash struct {
	DBhash               []byte   `protobuf:"bytes,1,opt,name=DBhash,proto3" json:"DBhash,omitempty"`
	Datahash             []byte   `protobuf:"bytes,2,opt,name=Datahash,proto3" json:"Datahash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HashToHash) Reset()         { *m = HashToHash{} }
func (m *HashToHash) String() string { return proto.CompactTextString(m) }
func (*HashToHash) ProtoMessage()    {}
func (*HashToHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{27}
}
func (m *HashToHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashToHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashToHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashToHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashToHash.Merge(m, src)
}
func (m *HashToHash) XXX_Size() int {
	return m.Size()
}
func (m *HashToHash) XXX_DiscardUnknown() {
	xxx_messageInfo_HashToHash.DiscardUnknown(m)
}

var xxx_messageInfo_HashToHash proto.InternalMessageInfo

func (m *HashToHash) GetDBhash() []byte {
	if m != nil {
		return m.DBhash
	}
	return nil
}

func (m *HashToHash) GetDatahash() []byte {
	if m != nil {
		return m.Datahash
	}
	return nil
}

//id:矿机id，数字形式（比如：12398）
//entryth:校验的起始entry
//Num:本次校验的数目
//errNum:校验出错的分片数
//errCode:错误类型码
//errShard:错误的分片列表
//msgid = 0x58b7
type SelfVerifyResp struct {
	Id                   string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Entryth              string        `protobuf:"bytes,2,opt,name=entryth,proto3" json:"entryth,omitempty"`
	Num                  string        `protobuf:"bytes,3,opt,name=Num,proto3" json:"Num,omitempty"`
	ErrNum               string        `protobuf:"bytes,4,opt,name=errNum,proto3" json:"errNum,omitempty"`
	ErrCode              string        `protobuf:"bytes,5,opt,name=errCode,proto3" json:"errCode,omitempty"`
	ErrShard             []*HashToHash `protobuf:"bytes,6,rep,name=errShard,proto3" json:"errShard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SelfVerifyResp) Reset()         { *m = SelfVerifyResp{} }
func (m *SelfVerifyResp) String() string { return proto.CompactTextString(m) }
func (*SelfVerifyResp) ProtoMessage()    {}
func (*SelfVerifyResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{28}
}
func (m *SelfVerifyResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SelfVerifyResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SelfVerifyResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SelfVerifyResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SelfVerifyResp.Merge(m, src)
}
func (m *SelfVerifyResp) XXX_Size() int {
	return m.Size()
}
func (m *SelfVerifyResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SelfVerifyResp.DiscardUnknown(m)
}

var xxx_messageInfo_SelfVerifyResp proto.InternalMessageInfo

func (m *SelfVerifyResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SelfVerifyResp) GetEntryth() string {
	if m != nil {
		return m.Entryth
	}
	return ""
}

func (m *SelfVerifyResp) GetNum() string {
	if m != nil {
		return m.Num
	}
	return ""
}

func (m *SelfVerifyResp) GetErrNum() string {
	if m != nil {
		return m.ErrNum
	}
	return ""
}

func (m *SelfVerifyResp) GetErrCode() string {
	if m != nil {
		return m.ErrCode
	}
	return ""
}

func (m *SelfVerifyResp) GetErrShard() []*HashToHash {
	if m != nil {
		return m.ErrShard
	}
	return nil
}

//MessageID:0xe87a
type GcReq struct {
	DelPubKey            []byte   `protobuf:"bytes,1,opt,name=delPubKey,proto3" json:"delPubKey,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	TaskId               string   `protobuf:"bytes,3,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Gclist               [][]byte `protobuf:"bytes,4,rep,name=Gclist,proto3" json:"Gclist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcReq) Reset()         { *m = GcReq{} }
func (m *GcReq) String() string { return proto.CompactTextString(m) }
func (*GcReq) ProtoMessage()    {}
func (*GcReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{29}
}
func (m *GcReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcReq.Merge(m, src)
}
func (m *GcReq) XXX_Size() int {
	return m.Size()
}
func (m *GcReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GcReq.DiscardUnknown(m)
}

var xxx_messageInfo_GcReq proto.InternalMessageInfo

func (m *GcReq) GetDelPubKey() []byte {
	if m != nil {
		return m.DelPubKey
	}
	return nil
}

func (m *GcReq) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

func (m *GcReq) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcReq) GetGclist() [][]byte {
	if m != nil {
		return m.Gclist
	}
	return nil
}

//MessageID:0xe87b
type GcResp struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	ErrCode              string   `protobuf:"bytes,3,opt,name=ErrCode,proto3" json:"ErrCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcResp) Reset()         { *m = GcResp{} }
func (m *GcResp) String() string { return proto.CompactTextString(m) }
func (*GcResp) ProtoMessage()    {}
func (*GcResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{30}
}
func (m *GcResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcResp.Merge(m, src)
}
func (m *GcResp) XXX_Size() int {
	return m.Size()
}
func (m *GcResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GcResp.DiscardUnknown(m)
}

var xxx_messageInfo_GcResp proto.InternalMessageInfo

func (m *GcResp) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcResp) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

func (m *GcResp) GetErrCode() string {
	if m != nil {
		return m.ErrCode
	}
	return ""
}

//MessageID:0xe87e
type GcStatusReq struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcStatusReq) Reset()         { *m = GcStatusReq{} }
func (m *GcStatusReq) String() string { return proto.CompactTextString(m) }
func (*GcStatusReq) ProtoMessage()    {}
func (*GcStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{31}
}
func (m *GcStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcStatusReq.Merge(m, src)
}
func (m *GcStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *GcStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GcStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_GcStatusReq proto.InternalMessageInfo

func (m *GcStatusReq) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcStatusReq) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

//MessageID:0xe87f
type GcStatusResp struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	Total                int32    `protobuf:"varint,4,opt,name=total,proto3" json:"total,omitempty"`
	Fail                 int32    `protobuf:"varint,5,opt,name=fail,proto3" json:"fail,omitempty"`
	Errlist              [][]byte `protobuf:"bytes,6,rep,name=errlist,proto3" json:"errlist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcStatusResp) Reset()         { *m = GcStatusResp{} }
func (m *GcStatusResp) String() string { return proto.CompactTextString(m) }
func (*GcStatusResp) ProtoMessage()    {}
func (*GcStatusResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{32}
}
func (m *GcStatusResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcStatusResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcStatusResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcStatusResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcStatusResp.Merge(m, src)
}
func (m *GcStatusResp) XXX_Size() int {
	return m.Size()
}
func (m *GcStatusResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GcStatusResp.DiscardUnknown(m)
}

var xxx_messageInfo_GcStatusResp proto.InternalMessageInfo

func (m *GcStatusResp) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcStatusResp) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

func (m *GcStatusResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *GcStatusResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *GcStatusResp) GetFail() int32 {
	if m != nil {
		return m.Fail
	}
	return 0
}

func (m *GcStatusResp) GetErrlist() [][]byte {
	if m != nil {
		return m.Errlist
	}
	return nil
}

//MessageID:0xe88e
type GcdelStatusfileReq struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcdelStatusfileReq) Reset()         { *m = GcdelStatusfileReq{} }
func (m *GcdelStatusfileReq) String() string { return proto.CompactTextString(m) }
func (*GcdelStatusfileReq) ProtoMessage()    {}
func (*GcdelStatusfileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{33}
}
func (m *GcdelStatusfileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcdelStatusfileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcdelStatusfileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcdelStatusfileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcdelStatusfileReq.Merge(m, src)
}
func (m *GcdelStatusfileReq) XXX_Size() int {
	return m.Size()
}
func (m *GcdelStatusfileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GcdelStatusfileReq.DiscardUnknown(m)
}

var xxx_messageInfo_GcdelStatusfileReq proto.InternalMessageInfo

func (m *GcdelStatusfileReq) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcdelStatusfileReq) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

//MessageID:0xe88f
type GcdelStatusfileResp struct {
	TaskId               string   `protobuf:"bytes,1,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Dnid                 uint32   `protobuf:"varint,2,opt,name=dnid,proto3" json:"dnid,omitempty"`
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GcdelStatusfileResp) Reset()         { *m = GcdelStatusfileResp{} }
func (m *GcdelStatusfileResp) String() string { return proto.CompactTextString(m) }
func (*GcdelStatusfileResp) ProtoMessage()    {}
func (*GcdelStatusfileResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{34}
}
func (m *GcdelStatusfileResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GcdelStatusfileResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GcdelStatusfileResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GcdelStatusfileResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GcdelStatusfileResp.Merge(m, src)
}
func (m *GcdelStatusfileResp) XXX_Size() int {
	return m.Size()
}
func (m *GcdelStatusfileResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GcdelStatusfileResp.DiscardUnknown(m)
}

var xxx_messageInfo_GcdelStatusfileResp proto.InternalMessageInfo

func (m *GcdelStatusfileResp) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *GcdelStatusfileResp) GetDnid() uint32 {
	if m != nil {
		return m.Dnid
	}
	return 0
}

func (m *GcdelStatusfileResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

//MessageID:0x1b32
type DownloadYTFSFile struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ServerUrl            string   `protobuf:"bytes,2,opt,name=serverUrl,proto3" json:"serverUrl,omitempty"`
	Gzip                 bool     `protobuf:"varint,3,opt,name=gzip,proto3" json:"gzip,omitempty"`
	Sig                  []byte   `protobuf:"bytes,4,opt,name=sig,proto3" json:"sig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadYTFSFile) Reset()         { *m = DownloadYTFSFile{} }
func (m *DownloadYTFSFile) String() string { return proto.CompactTextString(m) }
func (*DownloadYTFSFile) ProtoMessage()    {}
func (*DownloadYTFSFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{35}
}
func (m *DownloadYTFSFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadYTFSFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadYTFSFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadYTFSFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadYTFSFile.Merge(m, src)
}
func (m *DownloadYTFSFile) XXX_Size() int {
	return m.Size()
}
func (m *DownloadYTFSFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadYTFSFile.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadYTFSFile proto.InternalMessageInfo

func (m *DownloadYTFSFile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DownloadYTFSFile) GetServerUrl() string {
	if m != nil {
		return m.ServerUrl
	}
	return ""
}

func (m *DownloadYTFSFile) GetGzip() bool {
	if m != nil {
		return m.Gzip
	}
	return false
}

func (m *DownloadYTFSFile) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

//MessageID:0x1b33
type Debug struct {
	ServerUrl            string   `protobuf:"bytes,1,opt,name=serverUrl,proto3" json:"serverUrl,omitempty"`
	Sig                  []byte   `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Debug) Reset()         { *m = Debug{} }
func (m *Debug) String() string { return proto.CompactTextString(m) }
func (*Debug) ProtoMessage()    {}
func (*Debug) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{36}
}
func (m *Debug) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Debug) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Debug.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Debug) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Debug.Merge(m, src)
}
func (m *Debug) XXX_Size() int {
	return m.Size()
}
func (m *Debug) XXX_DiscardUnknown() {
	xxx_messageInfo_Debug.DiscardUnknown(m)
}

var xxx_messageInfo_Debug proto.InternalMessageInfo

func (m *Debug) GetServerUrl() string {
	if m != nil {
		return m.ServerUrl
	}
	return ""
}

func (m *Debug) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

//MessageID:0x1b34
type DownloadTKCheck struct {
	Tk                   string   `protobuf:"bytes,1,opt,name=tk,proto3" json:"tk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadTKCheck) Reset()         { *m = DownloadTKCheck{} }
func (m *DownloadTKCheck) String() string { return proto.CompactTextString(m) }
func (*DownloadTKCheck) ProtoMessage()    {}
func (*DownloadTKCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{37}
}
func (m *DownloadTKCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadTKCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadTKCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadTKCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadTKCheck.Merge(m, src)
}
func (m *DownloadTKCheck) XXX_Size() int {
	return m.Size()
}
func (m *DownloadTKCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadTKCheck.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadTKCheck proto.InternalMessageInfo

func (m *DownloadTKCheck) GetTk() string {
	if m != nil {
		return m.Tk
	}
	return ""
}

//MessageID:0xe75c
type UploadShardRequestTest struct {
	SHARDID              int32    `protobuf:"varint,1,opt,name=SHARDID,proto3" json:"SHARDID,omitempty"`
	BPDID                int32    `protobuf:"varint,2,opt,name=BPDID,proto3" json:"BPDID,omitempty"`
	VBI                  int64    `protobuf:"varint,3,opt,name=VBI,proto3" json:"VBI,omitempty"`
	BPDSIGN              []byte   `protobuf:"bytes,4,opt,name=BPDSIGN,proto3" json:"BPDSIGN,omitempty"`
	DAT                  []byte   `protobuf:"bytes,5,opt,name=DAT,proto3" json:"DAT,omitempty"`
	VHF                  []byte   `protobuf:"bytes,6,opt,name=VHF,proto3" json:"VHF,omitempty"`
	USERSIGN             []byte   `protobuf:"bytes,7,opt,name=USERSIGN,proto3" json:"USERSIGN,omitempty"`
	AllocId              string   `protobuf:"bytes,8,opt,name=allocId,proto3" json:"allocId,omitempty"`
	Sleep                uint32   `protobuf:"varint,9,opt,name=Sleep,proto3" json:"Sleep,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadShardRequestTest) Reset()         { *m = UploadShardRequestTest{} }
func (m *UploadShardRequestTest) String() string { return proto.CompactTextString(m) }
func (*UploadShardRequestTest) ProtoMessage()    {}
func (*UploadShardRequestTest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{38}
}
func (m *UploadShardRequestTest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadShardRequestTest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadShardRequestTest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadShardRequestTest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadShardRequestTest.Merge(m, src)
}
func (m *UploadShardRequestTest) XXX_Size() int {
	return m.Size()
}
func (m *UploadShardRequestTest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadShardRequestTest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadShardRequestTest proto.InternalMessageInfo

func (m *UploadShardRequestTest) GetSHARDID() int32 {
	if m != nil {
		return m.SHARDID
	}
	return 0
}

func (m *UploadShardRequestTest) GetBPDID() int32 {
	if m != nil {
		return m.BPDID
	}
	return 0
}

func (m *UploadShardRequestTest) GetVBI() int64 {
	if m != nil {
		return m.VBI
	}
	return 0
}

func (m *UploadShardRequestTest) GetBPDSIGN() []byte {
	if m != nil {
		return m.BPDSIGN
	}
	return nil
}

func (m *UploadShardRequestTest) GetDAT() []byte {
	if m != nil {
		return m.DAT
	}
	return nil
}

func (m *UploadShardRequestTest) GetVHF() []byte {
	if m != nil {
		return m.VHF
	}
	return nil
}

func (m *UploadShardRequestTest) GetUSERSIGN() []byte {
	if m != nil {
		return m.USERSIGN
	}
	return nil
}

func (m *UploadShardRequestTest) GetAllocId() string {
	if m != nil {
		return m.AllocId
	}
	return ""
}

func (m *UploadShardRequestTest) GetSleep() uint32 {
	if m != nil {
		return m.Sleep
	}
	return 0
}

//MessageID:0xe76a  测试任务消息
type TestMinerPerfTask struct {
	TargetMa             []string `protobuf:"bytes,1,rep,name=targetMa,proto3" json:"targetMa,omitempty"`
	TestType             int32    `protobuf:"varint,2,opt,name=testType,proto3" json:"testType,omitempty"`
	TestTime             int64    `protobuf:"varint,3,opt,name=testTime,proto3" json:"testTime,omitempty"`
	TimeOut              int64    `protobuf:"varint,4,opt,name=timeOut,proto3" json:"timeOut,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMinerPerfTask) Reset()         { *m = TestMinerPerfTask{} }
func (m *TestMinerPerfTask) String() string { return proto.CompactTextString(m) }
func (*TestMinerPerfTask) ProtoMessage()    {}
func (*TestMinerPerfTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{39}
}
func (m *TestMinerPerfTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMinerPerfTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMinerPerfTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMinerPerfTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMinerPerfTask.Merge(m, src)
}
func (m *TestMinerPerfTask) XXX_Size() int {
	return m.Size()
}
func (m *TestMinerPerfTask) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMinerPerfTask.DiscardUnknown(m)
}

var xxx_messageInfo_TestMinerPerfTask proto.InternalMessageInfo

func (m *TestMinerPerfTask) GetTargetMa() []string {
	if m != nil {
		return m.TargetMa
	}
	return nil
}

func (m *TestMinerPerfTask) GetTestType() int32 {
	if m != nil {
		return m.TestType
	}
	return 0
}

func (m *TestMinerPerfTask) GetTestTime() int64 {
	if m != nil {
		return m.TestTime
	}
	return 0
}

func (m *TestMinerPerfTask) GetTimeOut() int64 {
	if m != nil {
		return m.TimeOut
	}
	return 0
}

//MessageID:0xe76b
type TestGetBlock struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Pld                  []byte   `protobuf:"bytes,2,opt,name=pld,proto3" json:"pld,omitempty"`
	AllocID              string   `protobuf:"bytes,3,opt,name=allocID,proto3" json:"allocID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestGetBlock) Reset()         { *m = TestGetBlock{} }
func (m *TestGetBlock) String() string { return proto.CompactTextString(m) }
func (*TestGetBlock) ProtoMessage()    {}
func (*TestGetBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{40}
}
func (m *TestGetBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGetBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGetBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGetBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGetBlock.Merge(m, src)
}
func (m *TestGetBlock) XXX_Size() int {
	return m.Size()
}
func (m *TestGetBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGetBlock.DiscardUnknown(m)
}

var xxx_messageInfo_TestGetBlock proto.InternalMessageInfo

func (m *TestGetBlock) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TestGetBlock) GetPld() []byte {
	if m != nil {
		return m.Pld
	}
	return nil
}

func (m *TestGetBlock) GetAllocID() string {
	if m != nil {
		return m.AllocID
	}
	return ""
}

//MessageID:0xe76c
type TestGetBlockRes struct {
	Msg                  []byte   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestGetBlockRes) Reset()         { *m = TestGetBlockRes{} }
func (m *TestGetBlockRes) String() string { return proto.CompactTextString(m) }
func (*TestGetBlockRes) ProtoMessage()    {}
func (*TestGetBlockRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{41}
}
func (m *TestGetBlockRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestGetBlockRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestGetBlockRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestGetBlockRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestGetBlockRes.Merge(m, src)
}
func (m *TestGetBlockRes) XXX_Size() int {
	return m.Size()
}
func (m *TestGetBlockRes) XXX_DiscardUnknown() {
	xxx_messageInfo_TestGetBlockRes.DiscardUnknown(m)
}

var xxx_messageInfo_TestGetBlockRes proto.InternalMessageInfo

func (m *TestGetBlockRes) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

//MessageID:0xe76d 测试任务返回
type TestMinerPerfTaskRes struct {
	TargetMa             []string `protobuf:"bytes,1,rep,name=targetMa,proto3" json:"targetMa,omitempty"`
	TestType             int32    `protobuf:"varint,2,opt,name=testType,proto3" json:"testType,omitempty"`
	SuccessCount         int64    `protobuf:"varint,3,opt,name=successCount,proto3" json:"successCount,omitempty"`
	ErrorCount           int64    `protobuf:"varint,4,opt,name=errorCount,proto3" json:"errorCount,omitempty"`
	SuccessLatency       int64    `protobuf:"varint,5,opt,name=successLatency,proto3" json:"successLatency,omitempty"`
	ErrorLatency         int64    `protobuf:"varint,6,opt,name=errorLatency,proto3" json:"errorLatency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMinerPerfTaskRes) Reset()         { *m = TestMinerPerfTaskRes{} }
func (m *TestMinerPerfTaskRes) String() string { return proto.CompactTextString(m) }
func (*TestMinerPerfTaskRes) ProtoMessage()    {}
func (*TestMinerPerfTaskRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{42}
}
func (m *TestMinerPerfTaskRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMinerPerfTaskRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMinerPerfTaskRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMinerPerfTaskRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMinerPerfTaskRes.Merge(m, src)
}
func (m *TestMinerPerfTaskRes) XXX_Size() int {
	return m.Size()
}
func (m *TestMinerPerfTaskRes) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMinerPerfTaskRes.DiscardUnknown(m)
}

var xxx_messageInfo_TestMinerPerfTaskRes proto.InternalMessageInfo

func (m *TestMinerPerfTaskRes) GetTargetMa() []string {
	if m != nil {
		return m.TargetMa
	}
	return nil
}

func (m *TestMinerPerfTaskRes) GetTestType() int32 {
	if m != nil {
		return m.TestType
	}
	return 0
}

func (m *TestMinerPerfTaskRes) GetSuccessCount() int64 {
	if m != nil {
		return m.SuccessCount
	}
	return 0
}

func (m *TestMinerPerfTaskRes) GetErrorCount() int64 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *TestMinerPerfTaskRes) GetSuccessLatency() int64 {
	if m != nil {
		return m.SuccessLatency
	}
	return 0
}

func (m *TestMinerPerfTaskRes) GetErrorLatency() int64 {
	if m != nil {
		return m.ErrorLatency
	}
	return 0
}

func init() {
	proto.RegisterType((*NodeCapacityRequest)(nil), "message.NodeCapacityRequest")
	proto.RegisterType((*NodeCapacityResponse)(nil), "message.NodeCapacityResponse")
	proto.RegisterType((*UploadShardRequest)(nil), "message.UploadShardRequest")
	proto.RegisterType((*UploadShardResponse)(nil), "message.UploadShardResponse")
	proto.RegisterType((*UploadShard2CResponse)(nil), "message.UploadShard2CResponse")
	proto.RegisterType((*DownloadShardRequest)(nil), "message.DownloadShardRequest")
	proto.RegisterType((*DownloadShardResponse)(nil), "message.DownloadShardResponse")
	proto.RegisterType((*NodeRegReq)(nil), "message.NodeRegReq")
	proto.RegisterType((*NodeRegResp)(nil), "message.NodeRegResp")
	proto.RegisterType((*StatusRepReq)(nil), "message.StatusRepReq")
	proto.RegisterType((*StatusRepResp)(nil), "message.StatusRepResp")
	proto.RegisterType((*ErrorMessage)(nil), "message.ErrorMessage")
	proto.RegisterType((*StringMsg)(nil), "message.StringMsg")
	proto.RegisterType((*SpotCheckTaskList)(nil), "message.SpotCheckTaskList")
	proto.RegisterType((*SpotCheckTask)(nil), "message.SpotCheckTask")
	proto.RegisterType((*SpotCheckStatus)(nil), "message.SpotCheckStatus")
	proto.RegisterType((*TaskDescription)(nil), "message.TaskDescription")
	proto.RegisterType((*TaskDescriptionCP)(nil), "message.TaskDescriptionCP")
	proto.RegisterType((*P2PLocation)(nil), "message.P2PLocation")
	proto.RegisterType((*VoidResponse)(nil), "message.VoidResponse")
	proto.RegisterType((*TaskOpResult)(nil), "message.TaskOpResult")
	proto.RegisterType((*MultiTaskDescription)(nil), "message.MultiTaskDescription")
	proto.RegisterType((*MultiTaskOpResult)(nil), "message.MultiTaskOpResult")
	proto.RegisterType((*MultiTaskOpResultRes)(nil), "message.MultiTaskOpResultRes")
	proto.RegisterType((*ListDNIReq)(nil), "message.ListDNIReq")
	proto.RegisterType((*ListDNIResp)(nil), "message.ListDNIResp")
	proto.RegisterType((*SelfVerifyReq)(nil), "message.SelfVerifyReq")
	proto.RegisterType((*HashToHash)(nil), "message.HashToHash")
	proto.RegisterType((*SelfVerifyResp)(nil), "message.SelfVerifyResp")
	proto.RegisterType((*GcReq)(nil), "message.GcReq")
	proto.RegisterType((*GcResp)(nil), "message.GcResp")
	proto.RegisterType((*GcStatusReq)(nil), "message.GcStatusReq")
	proto.RegisterType((*GcStatusResp)(nil), "message.GcStatusResp")
	proto.RegisterType((*GcdelStatusfileReq)(nil), "message.GcdelStatusfileReq")
	proto.RegisterType((*GcdelStatusfileResp)(nil), "message.GcdelStatusfileResp")
	proto.RegisterType((*DownloadYTFSFile)(nil), "message.DownloadYTFSFile")
	proto.RegisterType((*Debug)(nil), "message.Debug")
	proto.RegisterType((*DownloadTKCheck)(nil), "message.DownloadTKCheck")
	proto.RegisterType((*UploadShardRequestTest)(nil), "message.UploadShardRequestTest")
	proto.RegisterType((*TestMinerPerfTask)(nil), "message.TestMinerPerfTask")
	proto.RegisterType((*TestGetBlock)(nil), "message.TestGetBlock")
	proto.RegisterType((*TestGetBlockRes)(nil), "message.TestGetBlockRes")
	proto.RegisterType((*TestMinerPerfTaskRes)(nil), "message.TestMinerPerfTaskRes")
}

func init() { proto.RegisterFile("message.proto", fileDescriptor_33c57e4bae7b9afd) }

var fileDescriptor_33c57e4bae7b9afd = []byte{
	// 1685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x6f, 0x23, 0x49,
	0x15, 0xa7, 0xdd, 0xb1, 0x63, 0xbf, 0xd8, 0x49, 0xa6, 0x27, 0x1b, 0xb5, 0x46, 0x43, 0xe4, 0x2d,
	0x10, 0xb2, 0x40, 0x5a, 0x50, 0x40, 0x42, 0x0b, 0x07, 0x76, 0x12, 0xcf, 0x64, 0xcc, 0x26, 0x99,
	0xa8, 0x9c, 0x19, 0x69, 0x0f, 0x08, 0x75, 0xba, 0x2b, 0x76, 0x93, 0x76, 0x77, 0x4f, 0x55, 0x39,
	0x93, 0x70, 0xe3, 0x8a, 0xc4, 0x15, 0xf1, 0x2d, 0xb8, 0xc0, 0x8d, 0x0f, 0x80, 0x38, 0xf1, 0x09,
	0x10, 0x1a, 0xf8, 0x20, 0xe8, 0xbd, 0xaa, 0xfe, 0x67, 0x67, 0x17, 0xcd, 0x8a, 0x0b, 0xb7, 0xfa,
	0xbd, 0xae, 0x7a, 0xf5, 0x7b, 0xaf, 0xde, 0x3f, 0x1b, 0x06, 0x0b, 0xa1, 0x54, 0x30, 0x13, 0x9f,
	0xe4, 0x32, 0xd3, 0x99, 0xb7, 0x69, 0x21, 0xfb, 0x14, 0x1e, 0x9f, 0x67, 0x91, 0x38, 0x0e, 0xf2,
	0x20, 0x8c, 0xf5, 0x3d, 0x17, 0x6f, 0x97, 0x42, 0x69, 0x8f, 0x41, 0xdf, 0x2e, 0xcf, 0xd4, 0x6c,
	0x32, 0xf6, 0x9d, 0xa1, 0x33, 0x6a, 0xf3, 0x86, 0x8c, 0x9d, 0xc2, 0x5e, 0xf3, 0xa8, 0xca, 0xb3,
	0x54, 0x09, 0xef, 0x09, 0x74, 0xdf, 0xc9, 0x58, 0x07, 0x57, 0x89, 0xa0, 0x73, 0x5d, 0x5e, 0x62,
	0xcf, 0x87, 0xcd, 0x20, 0x49, 0xb2, 0x70, 0x12, 0xf9, 0xad, 0xa1, 0x33, 0xea, 0xf1, 0x02, 0xb2,
	0xbf, 0x39, 0xe0, 0xbd, 0xce, 0x93, 0x2c, 0x88, 0xa6, 0xf3, 0x40, 0x46, 0x05, 0x11, 0x1f, 0x36,
	0xa7, 0x2f, 0x9f, 0xf1, 0x71, 0xc9, 0xa1, 0x80, 0xde, 0x1e, 0xb4, 0x8f, 0x2e, 0x50, 0xde, 0x22,
	0xb9, 0x01, 0xde, 0x2e, 0xb8, 0x6f, 0x8e, 0x26, 0xbe, 0x3b, 0x74, 0x46, 0x2e, 0xc7, 0x25, 0x6a,
	0x38, 0xba, 0x18, 0x4f, 0x27, 0x27, 0xe7, 0xfe, 0xc6, 0xd0, 0x19, 0xf5, 0x79, 0x01, 0x71, 0xef,
	0xf8, 0xd9, 0xa5, 0xdf, 0x26, 0x29, 0x2e, 0xe9, 0xf4, 0xcb, 0x17, 0x7e, 0xc7, 0x48, 0xde, 0xbc,
	0x7c, 0x81, 0xc6, 0xbc, 0x9e, 0x3e, 0xe7, 0x74, 0x7c, 0x93, 0xc4, 0x25, 0xae, 0x1b, 0xd3, 0x6d,
	0x1a, 0xf3, 0x1b, 0x07, 0x1e, 0x37, 0x8c, 0xb1, 0xae, 0xd9, 0x05, 0x97, 0x3f, 0x9f, 0x5a, 0x4b,
	0x70, 0x59, 0xb7, 0xaf, 0xd5, 0xb4, 0x6f, 0xdd, 0x12, 0xcb, 0x6e, 0xe3, 0x61, 0x76, 0xed, 0x26,
	0x3b, 0xf6, 0x0c, 0x3e, 0xaa, 0x51, 0x38, 0x3c, 0xfe, 0x0a, 0x12, 0xfb, 0xd0, 0x19, 0x9f, 0x93,
	0x12, 0xf3, 0x28, 0x16, 0xb1, 0x23, 0xd8, 0x1b, 0x67, 0xef, 0xd2, 0xb5, 0x47, 0xb1, 0x44, 0x9c,
	0x8a, 0xc8, 0x97, 0xbf, 0xeb, 0xf7, 0xe0, 0xa3, 0x15, 0x1d, 0x96, 0x86, 0x07, 0x1b, 0x51, 0xa0,
	0x03, 0xab, 0x85, 0xd6, 0xec, 0xb7, 0x0e, 0x00, 0xc6, 0x14, 0x17, 0x33, 0x2e, 0xde, 0x22, 0xaf,
	0x34, 0x8b, 0x44, 0x1c, 0xd1, 0xa6, 0x1e, 0xb7, 0x08, 0x9f, 0x3e, 0x7b, 0x97, 0x0a, 0x69, 0xef,
	0x32, 0x00, 0x63, 0x76, 0x11, 0xdc, 0x8d, 0x03, 0x1d, 0x4c, 0xf3, 0x20, 0x14, 0xe4, 0xb9, 0x0d,
	0xde, 0x90, 0xe1, 0xc9, 0x20, 0x8a, 0xa4, 0xf2, 0x37, 0x86, 0x2e, 0x9e, 0x24, 0x80, 0x52, 0x29,
	0x92, 0xe0, 0x9e, 0x7c, 0xd8, 0xe5, 0x06, 0xb0, 0x5f, 0xc2, 0x56, 0xc9, 0x45, 0xe5, 0xde, 0x36,
	0xb4, 0x2c, 0x91, 0x01, 0x6f, 0xc5, 0x91, 0xf7, 0x6d, 0x18, 0x04, 0x4a, 0xc5, 0xb3, 0x54, 0x44,
	0xe6, 0xbe, 0x16, 0xdd, 0xd7, 0x14, 0xe2, 0x0b, 0x91, 0xb6, 0xd7, 0x32, 0x21, 0x42, 0x3d, 0x5e,
	0x62, 0xf6, 0x17, 0x17, 0xfa, 0x53, 0x1d, 0xe8, 0xa5, 0xe2, 0x22, 0x47, 0x7b, 0x57, 0xaf, 0xd8,
	0x05, 0x37, 0xcc, 0x97, 0xa4, 0x78, 0xc0, 0x71, 0x89, 0x1e, 0x59, 0x88, 0x45, 0x26, 0xef, 0x49,
	0xd9, 0x80, 0x5b, 0xe4, 0x3d, 0x85, 0xde, 0x55, 0x90, 0x46, 0xef, 0xe2, 0x48, 0xcf, 0x29, 0x40,
	0x06, 0xbc, 0x12, 0xac, 0x79, 0xa6, 0xfd, 0x80, 0x67, 0xd6, 0xcc, 0xe9, 0x3c, 0x64, 0xce, 0x53,
	0xe8, 0x2d, 0x55, 0xb1, 0x63, 0x93, 0x76, 0x54, 0x82, 0xca, 0xbb, 0xdd, 0x07, 0xbd, 0xdb, 0xab,
	0x79, 0x17, 0x23, 0xe6, 0x56, 0x48, 0x15, 0x67, 0xa9, 0x0f, 0xc4, 0xb7, 0x80, 0xde, 0x01, 0x80,
	0x14, 0x57, 0xcb, 0x38, 0x89, 0xe2, 0x74, 0xe6, 0x6f, 0xd1, 0xc7, 0x9a, 0x04, 0x39, 0x48, 0x11,
	0x24, 0x86, 0x43, 0xdf, 0xd8, 0x5a, 0x0a, 0xd0, 0x87, 0xfa, 0xce, 0x1f, 0x10, 0xb5, 0x96, 0xbe,
	0x43, 0x2c, 0xef, 0xfc, 0x6d, 0x83, 0xe5, 0x1d, 0xb2, 0x79, 0xa5, 0xe7, 0x42, 0xfa, 0x3b, 0x26,
	0x76, 0x08, 0x60, 0x30, 0xce, 0x03, 0x35, 0xf7, 0x77, 0x49, 0x48, 0x6b, 0xe4, 0x41, 0x41, 0x6c,
	0x2e, 0x7a, 0x44, 0x1a, 0x6a, 0x12, 0xf6, 0x1a, 0x06, 0xb5, 0xd7, 0x53, 0xb9, 0x37, 0x82, 0x9d,
	0x5c, 0x66, 0xd1, 0x32, 0xd4, 0xf1, 0xad, 0x30, 0xa7, 0x1c, 0xca, 0xde, 0x55, 0x71, 0x23, 0x2a,
	0x5a, 0x2b, 0x51, 0xf1, 0x23, 0xe8, 0x3f, 0x97, 0x32, 0x93, 0x67, 0xa6, 0x42, 0x23, 0xb5, 0x30,
	0x8b, 0x84, 0xcd, 0x57, 0x5a, 0x63, 0x60, 0x2c, 0xd4, 0xcc, 0x1e, 0xc5, 0x25, 0xfb, 0x26, 0xf4,
	0xa6, 0x5a, 0xc6, 0xe9, 0xec, 0x4c, 0xcd, 0x8a, 0xcf, 0x4e, 0xf5, 0xf9, 0x77, 0x0e, 0x3c, 0x9a,
	0xe6, 0x99, 0x3e, 0x9e, 0x8b, 0xf0, 0xe6, 0x32, 0x50, 0x37, 0xa7, 0xb1, 0xd2, 0x18, 0x4d, 0x3a,
	0x50, 0x37, 0x93, 0x32, 0xbf, 0x0c, 0xc2, 0x2b, 0x55, 0x1a, 0x47, 0xb6, 0x22, 0xd1, 0xda, 0x3b,
	0x84, 0xae, 0xb6, 0xe7, 0x7c, 0x77, 0xe8, 0x8e, 0xb6, 0x0e, 0xf7, 0x3f, 0x29, 0x7a, 0x4a, 0x43,
	0x33, 0x2f, 0xf7, 0xd5, 0xab, 0xc2, 0x46, 0xb3, 0x2a, 0xfc, 0x02, 0x06, 0x8d, 0x43, 0xb5, 0xd0,
	0x6f, 0x53, 0xe8, 0xdb, 0xd4, 0x2f, 0xeb, 0x89, 0x45, 0x48, 0x0d, 0xa3, 0xca, 0xe6, 0x12, 0xad,
	0xd7, 0xeb, 0x22, 0x9b, 0xc2, 0x4e, 0xa9, 0xde, 0xbc, 0xd1, 0x97, 0xda, 0x3a, 0x82, 0x9d, 0x38,
	0xbd, 0x0d, 0x92, 0x38, 0xc2, 0x64, 0x27, 0xf3, 0x5a, 0x43, 0x77, 0xd4, 0xe6, 0xab, 0x62, 0xf6,
	0x67, 0x07, 0x76, 0x90, 0xeb, 0x58, 0xa8, 0x50, 0xc6, 0xb9, 0xc6, 0x58, 0xad, 0x68, 0xf7, 0x89,
	0xf6, 0x1e, 0xb4, 0x31, 0x76, 0x14, 0xe9, 0xe8, 0x73, 0x03, 0xbc, 0x43, 0xe8, 0x25, 0x59, 0x18,
	0xe0, 0x09, 0x65, 0x9d, 0xb7, 0x57, 0x3a, 0xef, 0xe2, 0xf0, 0xe2, 0xd4, 0x7e, 0xe4, 0xd5, 0x36,
	0xef, 0xbb, 0xb0, 0x9b, 0x07, 0x32, 0xd6, 0xf7, 0x54, 0x35, 0x8f, 0xb3, 0x65, 0xaa, 0xc9, 0xc2,
	0x36, 0x5f, 0x93, 0x9b, 0x8c, 0x08, 0xb3, 0x5b, 0x21, 0x27, 0x11, 0x25, 0x77, 0x9b, 0x57, 0x02,
	0xa6, 0xe0, 0xd1, 0x0a, 0xed, 0xe3, 0x8b, 0x35, 0xe2, 0x4f, 0xa0, 0x8b, 0x15, 0xf8, 0x25, 0x26,
	0x41, 0xcb, 0x74, 0x92, 0x02, 0x7f, 0x1d, 0xfa, 0xec, 0xa7, 0xb0, 0x55, 0xfb, 0x52, 0x7b, 0x4e,
	0xa7, 0xf1, 0x9c, 0x65, 0xc5, 0x68, 0xd5, 0x2a, 0x06, 0xdb, 0x86, 0xfe, 0x9b, 0x2c, 0x2e, 0x5b,
	0x05, 0xfb, 0x01, 0xf4, 0xd1, 0x82, 0x57, 0x98, 0x66, 0xcb, 0x44, 0xaf, 0x91, 0xb7, 0x1d, 0xad,
	0x55, 0x76, 0x34, 0xf6, 0x27, 0x07, 0xf6, 0xce, 0x96, 0x89, 0x8e, 0x57, 0x1f, 0xec, 0x89, 0x09,
	0xe3, 0x04, 0xdf, 0xd9, 0xa1, 0x37, 0x2a, 0xb1, 0x37, 0x84, 0x2d, 0x71, 0x97, 0xc7, 0x52, 0x44,
	0x97, 0xf1, 0xc2, 0xd4, 0x73, 0x97, 0xd7, 0x45, 0xe8, 0x68, 0x25, 0x43, 0x8c, 0x88, 0xc9, 0x98,
	0x42, 0xb0, 0xcd, 0x2b, 0x81, 0xf7, 0x1d, 0xd8, 0xae, 0x6d, 0x3e, 0x09, 0x72, 0xfb, 0x60, 0x2b,
	0xd2, 0x7a, 0x5a, 0xb4, 0x9b, 0x69, 0x81, 0x69, 0x5a, 0xd2, 0x5e, 0x33, 0xd7, 0x5d, 0x35, 0xd7,
	0xad, 0x35, 0xf0, 0x06, 0x29, 0x8b, 0x56, 0x2d, 0xda, 0xf8, 0x2f, 0x16, 0xb5, 0x57, 0x2c, 0x62,
	0x3f, 0xaf, 0x79, 0xb1, 0xa0, 0xc3, 0x85, 0x42, 0x0b, 0x84, 0x94, 0xc7, 0x55, 0x59, 0x2a, 0x20,
	0xcd, 0x33, 0xcb, 0x30, 0x3c, 0x5f, 0x2e, 0xca, 0x79, 0xc6, 0x40, 0xf6, 0x13, 0x00, 0x4c, 0xa3,
	0xf1, 0xf9, 0xa4, 0x68, 0xed, 0xe2, 0x4e, 0xd7, 0x5a, 0x3b, 0x21, 0x0c, 0x88, 0x90, 0x62, 0xdd,
	0x4e, 0x75, 0x04, 0xd8, 0xcf, 0x60, 0xab, 0x3c, 0xab, 0xc8, 0x81, 0xb7, 0xe9, 0x75, 0xed, 0x0d,
	0x0b, 0x58, 0x53, 0xdb, 0xaa, 0xab, 0x65, 0x1f, 0xc3, 0x60, 0x2a, 0x92, 0xeb, 0x37, 0x42, 0xc6,
	0xd7, 0x38, 0xe4, 0xa2, 0x0f, 0x91, 0xa3, 0x2d, 0x91, 0xc8, 0xef, 0x33, 0x00, 0x8c, 0xf6, 0xcb,
	0x8c, 0x62, 0x1e, 0x47, 0xa2, 0x23, 0x6a, 0x09, 0x26, 0xcc, 0x2c, 0xc2, 0xf8, 0xc1, 0x9e, 0x39,
	0xaf, 0xe5, 0x49, 0x81, 0xd9, 0x1f, 0x1d, 0xd8, 0xae, 0xdf, 0xd2, 0x18, 0x1a, 0x7a, 0xf4, 0x74,
	0xe8, 0xb8, 0x54, 0xcb, 0x7b, 0x3d, 0x2f, 0xe6, 0x24, 0x0b, 0x0b, 0x42, 0x6e, 0x49, 0x08, 0x29,
	0x08, 0x29, 0x51, 0x68, 0x8a, 0xa7, 0x45, 0x75, 0xe7, 0xdb, 0xf0, 0x29, 0x9c, 0xff, 0x7d, 0xe8,
	0x0a, 0x29, 0xa9, 0x30, 0xf8, 0x1d, 0xca, 0xd3, 0xc7, 0x65, 0x9e, 0x56, 0xb6, 0xf1, 0x72, 0x13,
	0x8b, 0xa1, 0x7d, 0x12, 0xa2, 0x3b, 0x9e, 0x42, 0x2f, 0x12, 0xc9, 0xc5, 0xf2, 0xea, 0x73, 0x71,
	0x6f, 0x2d, 0xae, 0x04, 0x34, 0xaa, 0x15, 0xfd, 0x60, 0xc0, 0x69, 0x5d, 0xab, 0xa7, 0x6e, 0xa3,
	0x9e, 0xee, 0x43, 0xe7, 0x24, 0xa4, 0xa7, 0xd9, 0xa0, 0xa7, 0xb1, 0x88, 0x9d, 0xa3, 0x9c, 0x7c,
	0xf2, 0x15, 0x5d, 0x67, 0xed, 0x16, 0x1f, 0x36, 0x9f, 0x5b, 0x5b, 0xcd, 0x35, 0x05, 0x64, 0x9f,
	0xc2, 0xd6, 0x49, 0x58, 0xf4, 0xdf, 0xb7, 0x1f, 0xa2, 0x94, 0xfd, 0xde, 0x81, 0x7e, 0x75, 0xf6,
	0x03, 0x19, 0xed, 0x43, 0x47, 0xd1, 0xc9, 0xc2, 0x6e, 0x83, 0x30, 0x70, 0x75, 0xa6, 0x83, 0xc4,
	0xe6, 0xbc, 0x01, 0xa8, 0xe1, 0x3a, 0x88, 0x13, 0x9b, 0x59, 0xb4, 0xb6, 0xef, 0x47, 0x2e, 0xea,
	0x98, 0xe8, 0xb5, 0x90, 0x7d, 0x06, 0xde, 0x49, 0x18, 0x89, 0xc4, 0x50, 0xbb, 0x8e, 0x13, 0xf1,
	0xa1, 0xa6, 0x7d, 0x01, 0x8f, 0xd7, 0x34, 0xfc, 0x6f, 0x0c, 0x64, 0xbf, 0x82, 0xdd, 0x62, 0x90,
	0xff, 0xe2, 0xf2, 0xc5, 0xf4, 0x45, 0x9c, 0xd0, 0x6c, 0x92, 0x06, 0x0b, 0x61, 0xb5, 0xd2, 0x9a,
	0x2a, 0x8a, 0x90, 0xb7, 0x42, 0x56, 0xc3, 0x4d, 0x25, 0xc0, 0x13, 0xb3, 0x5f, 0xc7, 0x39, 0xe9,
	0xee, 0x72, 0x5a, 0x63, 0xe8, 0xab, 0x78, 0x56, 0xf4, 0x6f, 0x15, 0xcf, 0xd8, 0x8f, 0xa1, 0x3d,
	0x16, 0x57, 0xcb, 0x59, 0x53, 0x99, 0xb3, 0xaa, 0xcc, 0x1e, 0x6c, 0x55, 0x07, 0x3f, 0x86, 0x9d,
	0x82, 0xe4, 0xe5, 0xe7, 0xd4, 0xfe, 0x69, 0x20, 0xbc, 0x29, 0x52, 0x50, 0xdf, 0xb0, 0x7f, 0x3b,
	0xb0, 0xbf, 0xfe, 0x43, 0xf3, 0xf2, 0xff, 0xf6, 0xc7, 0x26, 0x72, 0x9b, 0x26, 0x42, 0xe4, 0x34,
	0x5f, 0x0f, 0xb8, 0x01, 0xf8, 0x13, 0xf4, 0x11, 0x1a, 0x75, 0x16, 0xa7, 0x42, 0x5e, 0x08, 0x79,
	0x4d, 0x63, 0x16, 0xb5, 0x3f, 0x39, 0x13, 0xfa, 0x2c, 0xa0, 0xd2, 0xd9, 0xe3, 0x25, 0xa6, 0x6f,
	0xe8, 0x89, 0xfb, 0x5c, 0x58, 0x33, 0x4b, 0x5c, 0x7e, 0xc3, 0x2e, 0x62, 0xcc, 0x2d, 0x31, 0x32,
	0xd3, 0xf1, 0x42, 0xbc, 0x5a, 0x6a, 0xdb, 0x60, 0x0a, 0xc8, 0x4e, 0xa1, 0x8f, 0x14, 0x4e, 0x84,
	0x3e, 0x4a, 0xb2, 0xf0, 0x66, 0x7d, 0x2e, 0x45, 0x49, 0x9e, 0x44, 0xc5, 0x0b, 0xe6, 0x49, 0x54,
	0xd9, 0x39, 0x2e, 0x32, 0xde, 0x42, 0xf6, 0x2d, 0xd8, 0xa9, 0x6b, 0xc3, 0x3e, 0x54, 0x53, 0xd8,
	0x37, 0x83, 0xee, 0x3f, 0x1c, 0xd8, 0x5b, 0x33, 0x1b, 0xb7, 0x7e, 0x5d, 0xcb, 0x19, 0xf4, 0xd5,
	0x32, 0x0c, 0x85, 0x52, 0x66, 0x06, 0x33, 0xd6, 0x37, 0x64, 0xf8, 0x4b, 0x41, 0xe0, 0xc8, 0x5e,
	0x4d, 0x69, 0x2e, 0xaf, 0x49, 0x70, 0x30, 0xb0, 0xfb, 0x4f, 0x03, 0x2d, 0xd2, 0xd0, 0xfc, 0xd0,
	0x74, 0xf9, 0x8a, 0x14, 0xef, 0xa2, 0x53, 0xc5, 0xae, 0x8e, 0xb9, 0xab, 0x2e, 0x3b, 0xda, 0xfd,
	0xeb, 0xfb, 0x03, 0xe7, 0xef, 0xef, 0x0f, 0x9c, 0x7f, 0xbe, 0x3f, 0x70, 0xfe, 0xf0, 0xaf, 0x83,
	0x6f, 0x5c, 0x75, 0xe8, 0x2f, 0x9d, 0x1f, 0xfe, 0x27, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x5c, 0x19,
	0xcd, 0xe3, 0x11, 0x00, 0x00,
}

func (m *NodeCapacityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCapacityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCapacityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestMsgID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RequestMsgID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeCapacityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCapacityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCapacityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Writable {
		i--
		if m.Writable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.USERSIGN) > 0 {
		i -= len(m.USERSIGN)
		copy(dAtA[i:], m.USERSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.USERSIGN)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VHF) > 0 {
		i -= len(m.VHF)
		copy(dAtA[i:], m.VHF)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.VHF)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DAT) > 0 {
		i -= len(m.DAT)
		copy(dAtA[i:], m.DAT)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DAT)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BPDSIGN) > 0 {
		i -= len(m.BPDSIGN)
		copy(dAtA[i:], m.BPDSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.BPDSIGN)))
		i--
		dAtA[i] = 0x22
	}
	if m.VBI != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.VBI))
		i--
		dAtA[i] = 0x18
	}
	if m.BPDID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.BPDID))
		i--
		dAtA[i] = 0x10
	}
	if m.SHARDID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SHARDID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.USERSIGN) > 0 {
		i -= len(m.USERSIGN)
		copy(dAtA[i:], m.USERSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.USERSIGN)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VHF) > 0 {
		i -= len(m.VHF)
		copy(dAtA[i:], m.VHF)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.VHF)))
		i--
		dAtA[i] = 0x22
	}
	if m.VBI != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.VBI))
		i--
		dAtA[i] = 0x18
	}
	if m.SHARDID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SHARDID))
		i--
		dAtA[i] = 0x10
	}
	if m.RES != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RES))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadShard2CResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadShard2CResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadShard2CResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DNSIGN) > 0 {
		i -= len(m.DNSIGN)
		copy(dAtA[i:], m.DNSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DNSIGN)))
		i--
		dAtA[i] = 0x12
	}
	if m.RES != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RES))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VHF) > 0 {
		i -= len(m.VHF)
		copy(dAtA[i:], m.VHF)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.VHF)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeRegReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRegReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeRegReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Relay {
		i--
		if m.Relay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MaxDataSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MaxDataSpace))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nodeid) > 0 {
		i -= len(m.Nodeid)
		copy(dAtA[i:], m.Nodeid)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Nodeid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeRegResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRegResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeRegResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelayUrl) > 0 {
		i -= len(m.RelayUrl)
		copy(dAtA[i:], m.RelayUrl)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.RelayUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AssignedSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AssignedSpace))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatusRepReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusRepReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusRepReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllocSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AllocSpace))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Other) > 0 {
		i -= len(m.Other)
		copy(dAtA[i:], m.Other)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Other)))
		i--
		dAtA[i] = 0x7a
	}
	if m.Rx != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Rx))
		i--
		dAtA[i] = 0x70
	}
	if m.Tx != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Tx))
		i--
		dAtA[i] = 0x68
	}
	if m.RealSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RealSpace))
		i--
		dAtA[i] = 0x60
	}
	if m.Rebuilding != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Rebuilding))
		i--
		dAtA[i] = 0x58
	}
	if m.Version != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x50
	}
	if m.Relay {
		i--
		if m.Relay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.UsedSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x38
	}
	if m.AssignedSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.AssignedSpace))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxDataSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.MaxDataSpace))
		i--
		dAtA[i] = 0x28
	}
	if m.Bandwidth != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Bandwidth))
		i--
		dAtA[i] = 0x20
	}
	if m.Memory != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x18
	}
	if m.Cpu != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatusRepResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusRepResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusRepResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelayUrl) > 0 {
		i -= len(m.RelayUrl)
		copy(dAtA[i:], m.RelayUrl)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.RelayUrl)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProductiveSpace != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ProductiveSpace))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ErrorMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrorMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StringMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotCheckTaskList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotCheckTaskList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotCheckTaskList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TaskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Snid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Snid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpotCheckTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotCheckTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotCheckTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VHF) > 0 {
		i -= len(m.VHF)
		copy(dAtA[i:], m.VHF)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.VHF)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpotCheckStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpotCheckStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpotCheckStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InvalidNodeList) > 0 {
		dAtA2 := make([]byte, len(m.InvalidNodeList)*10)
		var j1 int
		for _, num1 := range m.InvalidNodeList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMessage(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecoverId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RecoverId))
		i--
		dAtA[i] = 0x28
	}
	if m.ParityShardCount != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ParityShardCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Hashs) > 0 {
		for iNdEx := len(m.Hashs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hashs[iNdEx])
			copy(dAtA[i:], m.Hashs[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Hashs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskDescriptionCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskDescriptionCP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskDescriptionCP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P2PLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P2PLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P2PLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoidResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoidResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TaskOpResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskOpResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskOpResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RES != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.RES))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiTaskDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiTaskDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiTaskDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ExpiredTimeGap != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ExpiredTimeGap))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcNodeID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SrcNodeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpiredTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ExpiredTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tasklist) > 0 {
		for iNdEx := len(m.Tasklist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tasklist[iNdEx])
			copy(dAtA[i:], m.Tasklist[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Tasklist[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiTaskOpResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiTaskOpResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiTaskOpResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcNodeID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SrcNodeID))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiredTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ExpiredTime))
		i--
		dAtA[i] = 0x20
	}
	if m.NodeID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RES) > 0 {
		dAtA4 := make([]byte, len(m.RES)*10)
		var j3 int
		for _, num1 := range m.RES {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMessage(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiTaskOpResultRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiTaskOpResultRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiTaskOpResultRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SuccNum != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SuccNum))
		i--
		dAtA[i] = 0x10
	}
	if m.ErrCode != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ErrCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListDNIReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDNIReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDNIReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Nextid) > 0 {
		i -= len(m.Nextid)
		copy(dAtA[i:], m.Nextid)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Nextid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDNIResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDNIResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDNIResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nextid) > 0 {
		i -= len(m.Nextid)
		copy(dAtA[i:], m.Nextid)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Nextid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vnflist) > 0 {
		for iNdEx := len(m.Vnflist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vnflist[iNdEx])
			copy(dAtA[i:], m.Vnflist[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Vnflist[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SelfVerifyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelfVerifyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SelfVerifyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Num) > 0 {
		i -= len(m.Num)
		copy(dAtA[i:], m.Num)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Num)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HashToHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashToHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashToHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datahash) > 0 {
		i -= len(m.Datahash)
		copy(dAtA[i:], m.Datahash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Datahash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DBhash) > 0 {
		i -= len(m.DBhash)
		copy(dAtA[i:], m.DBhash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DBhash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SelfVerifyResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelfVerifyResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SelfVerifyResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrShard) > 0 {
		for iNdEx := len(m.ErrShard) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErrShard[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ErrCode) > 0 {
		i -= len(m.ErrCode)
		copy(dAtA[i:], m.ErrCode)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ErrCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ErrNum) > 0 {
		i -= len(m.ErrNum)
		copy(dAtA[i:], m.ErrNum)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ErrNum)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Num) > 0 {
		i -= len(m.Num)
		copy(dAtA[i:], m.Num)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Num)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Entryth) > 0 {
		i -= len(m.Entryth)
		copy(dAtA[i:], m.Entryth)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Entryth)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Gclist) > 0 {
		for iNdEx := len(m.Gclist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Gclist[iNdEx])
			copy(dAtA[i:], m.Gclist[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Gclist[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DelPubKey) > 0 {
		i -= len(m.DelPubKey)
		copy(dAtA[i:], m.DelPubKey)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DelPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrCode) > 0 {
		i -= len(m.ErrCode)
		copy(dAtA[i:], m.ErrCode)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ErrCode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcStatusResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcStatusResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcStatusResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Errlist) > 0 {
		for iNdEx := len(m.Errlist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errlist[iNdEx])
			copy(dAtA[i:], m.Errlist[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.Errlist[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Fail != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Fail))
		i--
		dAtA[i] = 0x28
	}
	if m.Total != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcdelStatusfileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcdelStatusfileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcdelStatusfileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GcdelStatusfileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GcdelStatusfileResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GcdelStatusfileResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Dnid != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Dnid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadYTFSFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadYTFSFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadYTFSFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x22
	}
	if m.Gzip {
		i--
		if m.Gzip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerUrl) > 0 {
		i -= len(m.ServerUrl)
		copy(dAtA[i:], m.ServerUrl)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ServerUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Debug) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Debug) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Debug) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerUrl) > 0 {
		i -= len(m.ServerUrl)
		copy(dAtA[i:], m.ServerUrl)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ServerUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadTKCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadTKCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadTKCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tk) > 0 {
		i -= len(m.Tk)
		copy(dAtA[i:], m.Tk)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Tk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadShardRequestTest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadShardRequestTest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadShardRequestTest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sleep != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Sleep))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AllocId) > 0 {
		i -= len(m.AllocId)
		copy(dAtA[i:], m.AllocId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.USERSIGN) > 0 {
		i -= len(m.USERSIGN)
		copy(dAtA[i:], m.USERSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.USERSIGN)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VHF) > 0 {
		i -= len(m.VHF)
		copy(dAtA[i:], m.VHF)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.VHF)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DAT) > 0 {
		i -= len(m.DAT)
		copy(dAtA[i:], m.DAT)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.DAT)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BPDSIGN) > 0 {
		i -= len(m.BPDSIGN)
		copy(dAtA[i:], m.BPDSIGN)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.BPDSIGN)))
		i--
		dAtA[i] = 0x22
	}
	if m.VBI != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.VBI))
		i--
		dAtA[i] = 0x18
	}
	if m.BPDID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.BPDID))
		i--
		dAtA[i] = 0x10
	}
	if m.SHARDID != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SHARDID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestMinerPerfTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMinerPerfTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMinerPerfTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimeOut != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TimeOut))
		i--
		dAtA[i] = 0x20
	}
	if m.TestTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TestTime))
		i--
		dAtA[i] = 0x18
	}
	if m.TestType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TestType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TargetMa) > 0 {
		for iNdEx := len(m.TargetMa) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TargetMa[iNdEx])
			copy(dAtA[i:], m.TargetMa[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.TargetMa[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestGetBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGetBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGetBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllocID) > 0 {
		i -= len(m.AllocID)
		copy(dAtA[i:], m.AllocID)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.AllocID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pld) > 0 {
		i -= len(m.Pld)
		copy(dAtA[i:], m.Pld)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Pld)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestGetBlockRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestGetBlockRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestGetBlockRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestMinerPerfTaskRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMinerPerfTaskRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMinerPerfTaskRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ErrorLatency != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ErrorLatency))
		i--
		dAtA[i] = 0x30
	}
	if m.SuccessLatency != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SuccessLatency))
		i--
		dAtA[i] = 0x28
	}
	if m.ErrorCount != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x20
	}
	if m.SuccessCount != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SuccessCount))
		i--
		dAtA[i] = 0x18
	}
	if m.TestType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TestType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TargetMa) > 0 {
		for iNdEx := len(m.TargetMa) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TargetMa[iNdEx])
			copy(dAtA[i:], m.TargetMa[iNdEx])
			i = encodeVarintMessage(dAtA, i, uint64(len(m.TargetMa[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NodeCapacityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestMsgID != 0 {
		n += 1 + sovMessage(uint64(m.RequestMsgID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeCapacityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Writable {
		n += 2
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SHARDID != 0 {
		n += 1 + sovMessage(uint64(m.SHARDID))
	}
	if m.BPDID != 0 {
		n += 1 + sovMessage(uint64(m.BPDID))
	}
	if m.VBI != 0 {
		n += 1 + sovMessage(uint64(m.VBI))
	}
	l = len(m.BPDSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DAT)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.VHF)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.USERSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RES != 0 {
		n += 1 + sovMessage(uint64(m.RES))
	}
	if m.SHARDID != 0 {
		n += 1 + sovMessage(uint64(m.SHARDID))
	}
	if m.VBI != 0 {
		n += 1 + sovMessage(uint64(m.VBI))
	}
	l = len(m.VHF)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.USERSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadShard2CResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RES != 0 {
		n += 1 + sovMessage(uint64(m.RES))
	}
	l = len(m.DNSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VHF)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeRegReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nodeid)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.MaxDataSpace != 0 {
		n += 1 + sovMessage(uint64(m.MaxDataSpace))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.Relay {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeRegResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMessage(uint64(m.Id))
	}
	if m.AssignedSpace != 0 {
		n += 1 + sovMessage(uint64(m.AssignedSpace))
	}
	l = len(m.RelayUrl)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusRepReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMessage(uint64(m.Id))
	}
	if m.Cpu != 0 {
		n += 1 + sovMessage(uint64(m.Cpu))
	}
	if m.Memory != 0 {
		n += 1 + sovMessage(uint64(m.Memory))
	}
	if m.Bandwidth != 0 {
		n += 1 + sovMessage(uint64(m.Bandwidth))
	}
	if m.MaxDataSpace != 0 {
		n += 1 + sovMessage(uint64(m.MaxDataSpace))
	}
	if m.AssignedSpace != 0 {
		n += 1 + sovMessage(uint64(m.AssignedSpace))
	}
	if m.UsedSpace != 0 {
		n += 1 + sovMessage(uint64(m.UsedSpace))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.Relay {
		n += 2
	}
	if m.Version != 0 {
		n += 1 + sovMessage(uint64(m.Version))
	}
	if m.Rebuilding != 0 {
		n += 1 + sovMessage(uint64(m.Rebuilding))
	}
	if m.RealSpace != 0 {
		n += 1 + sovMessage(uint64(m.RealSpace))
	}
	if m.Tx != 0 {
		n += 1 + sovMessage(uint64(m.Tx))
	}
	if m.Rx != 0 {
		n += 1 + sovMessage(uint64(m.Rx))
	}
	l = len(m.Other)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 2 + l + sovMessage(uint64(l))
	}
	if m.AllocSpace != 0 {
		n += 2 + sovMessage(uint64(m.AllocSpace))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusRepResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductiveSpace != 0 {
		n += 1 + sovMessage(uint64(m.ProductiveSpace))
	}
	l = len(m.RelayUrl)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMessage(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpotCheckTaskList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Snid != 0 {
		n += 1 + sovMessage(uint64(m.Snid))
	}
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpotCheckTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMessage(uint64(m.Id))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.VHF)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpotCheckStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.InvalidNodeList) > 0 {
		l = 0
		for _, e := range m.InvalidNodeList {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Hashs) > 0 {
		for _, b := range m.Hashs {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.ParityShardCount != 0 {
		n += 1 + sovMessage(uint64(m.ParityShardCount))
	}
	if m.RecoverId != 0 {
		n += 1 + sovMessage(uint64(m.RecoverId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskDescriptionCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *P2PLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoidResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskOpResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.RES != 0 {
		n += 1 + sovMessage(uint64(m.RES))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiTaskDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tasklist) > 0 {
		for _, b := range m.Tasklist {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.ExpiredTime != 0 {
		n += 1 + sovMessage(uint64(m.ExpiredTime))
	}
	if m.SrcNodeID != 0 {
		n += 1 + sovMessage(uint64(m.SrcNodeID))
	}
	if m.ExpiredTimeGap != 0 {
		n += 1 + sovMessage(uint64(m.ExpiredTimeGap))
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiTaskOpResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		for _, b := range m.Id {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if len(m.RES) > 0 {
		l = 0
		for _, e := range m.RES {
			l += sovMessage(uint64(e))
		}
		n += 1 + sovMessage(uint64(l)) + l
	}
	if m.NodeID != 0 {
		n += 1 + sovMessage(uint64(m.NodeID))
	}
	if m.ExpiredTime != 0 {
		n += 1 + sovMessage(uint64(m.ExpiredTime))
	}
	if m.SrcNodeID != 0 {
		n += 1 + sovMessage(uint64(m.SrcNodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiTaskOpResultRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovMessage(uint64(m.ErrCode))
	}
	if m.SuccNum != 0 {
		n += 1 + sovMessage(uint64(m.SuccNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDNIReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nextid)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMessage(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDNIResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vnflist) > 0 {
		for _, b := range m.Vnflist {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = len(m.Nextid)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SelfVerifyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Num)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashToHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DBhash)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Datahash)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SelfVerifyResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Entryth)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Num)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ErrNum)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ErrCode)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.ErrShard) > 0 {
		for _, e := range m.ErrShard {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelPubKey)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Gclist) > 0 {
		for _, b := range m.Gclist {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	l = len(m.ErrCode)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcStatusResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovMessage(uint64(m.Total))
	}
	if m.Fail != 0 {
		n += 1 + sovMessage(uint64(m.Fail))
	}
	if len(m.Errlist) > 0 {
		for _, b := range m.Errlist {
			l = len(b)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcdelStatusfileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GcdelStatusfileResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Dnid != 0 {
		n += 1 + sovMessage(uint64(m.Dnid))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadYTFSFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.ServerUrl)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Gzip {
		n += 2
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Debug) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerUrl)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadTKCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tk)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadShardRequestTest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SHARDID != 0 {
		n += 1 + sovMessage(uint64(m.SHARDID))
	}
	if m.BPDID != 0 {
		n += 1 + sovMessage(uint64(m.BPDID))
	}
	if m.VBI != 0 {
		n += 1 + sovMessage(uint64(m.VBI))
	}
	l = len(m.BPDSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.DAT)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.VHF)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.USERSIGN)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AllocId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Sleep != 0 {
		n += 1 + sovMessage(uint64(m.Sleep))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMinerPerfTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TargetMa) > 0 {
		for _, s := range m.TargetMa {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.TestType != 0 {
		n += 1 + sovMessage(uint64(m.TestType))
	}
	if m.TestTime != 0 {
		n += 1 + sovMessage(uint64(m.TestTime))
	}
	if m.TimeOut != 0 {
		n += 1 + sovMessage(uint64(m.TimeOut))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGetBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Pld)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.AllocID)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestGetBlockRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMinerPerfTaskRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TargetMa) > 0 {
		for _, s := range m.TargetMa {
			l = len(s)
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.TestType != 0 {
		n += 1 + sovMessage(uint64(m.TestType))
	}
	if m.SuccessCount != 0 {
		n += 1 + sovMessage(uint64(m.SuccessCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovMessage(uint64(m.ErrorCount))
	}
	if m.SuccessLatency != 0 {
		n += 1 + sovMessage(uint64(m.SuccessLatency))
	}
	if m.ErrorLatency != 0 {
		n += 1 + sovMessage(uint64(m.ErrorLatency))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeCapacityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCapacityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCapacityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMsgID", wireType)
			}
			m.RequestMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMsgID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCapacityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCapacityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCapacityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Writable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHARDID", wireType)
			}
			m.SHARDID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SHARDID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPDID", wireType)
			}
			m.BPDID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BPDID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBI", wireType)
			}
			m.VBI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VBI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPDSIGN", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BPDSIGN = append(m.BPDSIGN[:0], dAtA[iNdEx:postIndex]...)
			if m.BPDSIGN == nil {
				m.BPDSIGN = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DAT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DAT = append(m.DAT[:0], dAtA[iNdEx:postIndex]...)
			if m.DAT == nil {
				m.DAT = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHF", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VHF = append(m.VHF[:0], dAtA[iNdEx:postIndex]...)
			if m.VHF == nil {
				m.VHF = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field USERSIGN", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.USERSIGN = append(m.USERSIGN[:0], dAtA[iNdEx:postIndex]...)
			if m.USERSIGN == nil {
				m.USERSIGN = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RES", wireType)
			}
			m.RES = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RES |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHARDID", wireType)
			}
			m.SHARDID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SHARDID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBI", wireType)
			}
			m.VBI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VBI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHF", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VHF = append(m.VHF[:0], dAtA[iNdEx:postIndex]...)
			if m.VHF == nil {
				m.VHF = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field USERSIGN", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.USERSIGN = append(m.USERSIGN[:0], dAtA[iNdEx:postIndex]...)
			if m.USERSIGN == nil {
				m.USERSIGN = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadShard2CResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadShard2CResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadShard2CResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RES", wireType)
			}
			m.RES = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RES |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSIGN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSIGN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHF", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VHF = append(m.VHF[:0], dAtA[iNdEx:postIndex]...)
			if m.VHF == nil {
				m.VHF = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRegReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRegReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRegReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodeid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodeid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDataSpace", wireType)
			}
			m.MaxDataSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDataSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Relay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRegResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRegResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRegResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedSpace", wireType)
			}
			m.AssignedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusRepReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusRepReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusRepReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDataSpace", wireType)
			}
			m.MaxDataSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDataSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedSpace", wireType)
			}
			m.AssignedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Relay = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebuilding", wireType)
			}
			m.Rebuilding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rebuilding |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealSpace", wireType)
			}
			m.RealSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealSpace |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			m.Tx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rx", wireType)
			}
			m.Rx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Other = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocSpace", wireType)
			}
			m.AllocSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusRepResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusRepResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusRepResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductiveSpace", wireType)
			}
			m.ProductiveSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductiveSpace |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotCheckTaskList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotCheckTaskList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotCheckTaskList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snid", wireType)
			}
			m.Snid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskList = append(m.TaskList, &SpotCheckTask{})
			if err := m.TaskList[len(m.TaskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotCheckTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotCheckTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotCheckTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHF", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VHF = append(m.VHF[:0], dAtA[iNdEx:postIndex]...)
			if m.VHF == nil {
				m.VHF = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpotCheckStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpotCheckStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpotCheckStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InvalidNodeList = append(m.InvalidNodeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InvalidNodeList) == 0 {
					m.InvalidNodeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InvalidNodeList = append(m.InvalidNodeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidNodeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashs = append(m.Hashs, make([]byte, postIndex-iNdEx))
			copy(m.Hashs[len(m.Hashs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &P2PLocation{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParityShardCount", wireType)
			}
			m.ParityShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParityShardCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverId", wireType)
			}
			m.RecoverId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskDescriptionCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskDescriptionCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskDescriptionCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = append(m.DataHash[:0], dAtA[iNdEx:postIndex]...)
			if m.DataHash == nil {
				m.DataHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &P2PLocation{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P2PLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P2PLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P2PLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskOpResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskOpResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskOpResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RES", wireType)
			}
			m.RES = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RES |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiTaskDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiTaskDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiTaskDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasklist", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasklist = append(m.Tasklist, make([]byte, postIndex-iNdEx))
			copy(m.Tasklist[len(m.Tasklist)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			m.ExpiredTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNodeID", wireType)
			}
			m.SrcNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNodeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTimeGap", wireType)
			}
			m.ExpiredTimeGap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTimeGap |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiTaskOpResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiTaskOpResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiTaskOpResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, make([]byte, postIndex-iNdEx))
			copy(m.Id[len(m.Id)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RES = append(m.RES, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessage
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessage
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RES) == 0 {
					m.RES = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RES = append(m.RES, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RES", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			m.ExpiredTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNodeID", wireType)
			}
			m.SrcNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNodeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiTaskOpResultRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiTaskOpResultRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiTaskOpResultRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccNum", wireType)
			}
			m.SuccNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDNIReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDNIReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDNIReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nextid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nextid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDNIResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDNIResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDNIResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnflist", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vnflist = append(m.Vnflist, make([]byte, postIndex-iNdEx))
			copy(m.Vnflist[len(m.Vnflist)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nextid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nextid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelfVerifyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelfVerifyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelfVerifyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Num = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashToHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashToHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashToHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DBhash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DBhash = append(m.DBhash[:0], dAtA[iNdEx:postIndex]...)
			if m.DBhash == nil {
				m.DBhash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datahash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datahash = append(m.Datahash[:0], dAtA[iNdEx:postIndex]...)
			if m.Datahash == nil {
				m.Datahash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelfVerifyResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelfVerifyResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelfVerifyResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entryth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entryth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Num = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrShard = append(m.ErrShard, &HashToHash{})
			if err := m.ErrShard[len(m.ErrShard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelPubKey = append(m.DelPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.DelPubKey == nil {
				m.DelPubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gclist", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gclist = append(m.Gclist, make([]byte, postIndex-iNdEx))
			copy(m.Gclist[len(m.Gclist)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcStatusResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcStatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcStatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fail", wireType)
			}
			m.Fail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fail |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errlist", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errlist = append(m.Errlist, make([]byte, postIndex-iNdEx))
			copy(m.Errlist[len(m.Errlist)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcdelStatusfileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcdelStatusfileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcdelStatusfileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GcdelStatusfileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GcdelStatusfileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GcdelStatusfileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnid", wireType)
			}
			m.Dnid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dnid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadYTFSFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadYTFSFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadYTFSFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gzip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gzip = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Debug) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Debug: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Debug: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadTKCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadTKCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadTKCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadShardRequestTest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadShardRequestTest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadShardRequestTest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHARDID", wireType)
			}
			m.SHARDID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SHARDID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPDID", wireType)
			}
			m.BPDID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BPDID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBI", wireType)
			}
			m.VBI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VBI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPDSIGN", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BPDSIGN = append(m.BPDSIGN[:0], dAtA[iNdEx:postIndex]...)
			if m.BPDSIGN == nil {
				m.BPDSIGN = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DAT", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DAT = append(m.DAT[:0], dAtA[iNdEx:postIndex]...)
			if m.DAT == nil {
				m.DAT = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VHF", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VHF = append(m.VHF[:0], dAtA[iNdEx:postIndex]...)
			if m.VHF == nil {
				m.VHF = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field USERSIGN", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.USERSIGN = append(m.USERSIGN[:0], dAtA[iNdEx:postIndex]...)
			if m.USERSIGN == nil {
				m.USERSIGN = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sleep", wireType)
			}
			m.Sleep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sleep |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMinerPerfTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestMinerPerfTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestMinerPerfTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetMa = append(m.TargetMa, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestType", wireType)
			}
			m.TestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestTime", wireType)
			}
			m.TestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeOut", wireType)
			}
			m.TimeOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeOut |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGetBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGetBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGetBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pld", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pld = append(m.Pld[:0], dAtA[iNdEx:postIndex]...)
			if m.Pld == nil {
				m.Pld = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestGetBlockRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGetBlockRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGetBlockRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMinerPerfTaskRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestMinerPerfTaskRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestMinerPerfTaskRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetMa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetMa = append(m.TargetMa, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestType", wireType)
			}
			m.TestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessCount", wireType)
			}
			m.SuccessCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessLatency", wireType)
			}
			m.SuccessLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessLatency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorLatency", wireType)
			}
			m.ErrorLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorLatency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
